<!-- Generated by Heapkeeper v0.4 on 2010-04-10 13:44:39 -->
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>Thread hh/156</title>
    <link rel=stylesheet href="../heapindex.css" type="text/css">
  </head>
  <body>
    <h1 id="header">Thread hh/156</h1>


<div class="postbox"><!-- post hh/156 -->
<span class="postsummary" id="post_hh/156">
<span class="author">Attila Nagy</span>
<span class="subject">Body parsing - the what</span>
<span class="tags">[post syntax, prop]</span>
<span class="index"><a href="../hh/thread_156.html#post_hh/156">&lt;hh/156&gt;</a></span>
<span class="parent">&lt;root&gt;</span>
<span class="date">(2009-05-03)</span>
<div class="body">
<pre class="postbody">== The What ==

Our TODO sums it up pretty well, so I'll copy its points here:

* render URLs as links
* render post metas as links
** this may be obsolete
* handle an inline link syntax
** this'd be similar to MediaWiki's [<a href="http://url.com">http://url.com</a> URL] link renaming mechanism
* automatically add tags based on metas
** e.g. if body contains &lt;&lt;&lt;!todo X&gt;&gt;&gt;, add "todo" tag, change meta to
&lt;&lt;&lt;todo X&gt;&gt;&gt;
* handle cites
** this is probably one of the more challenging tasks
** already discussed
&lt;&lt;&lt;!link&gt;&gt;&gt;
* automatic actions on metas
** e.g. if body contains &lt;&lt;&lt;!tagthreadtag unix&gt;&gt;&gt;, add "unix" tag to
whole thread, remove meta
* show authors of quotes
** this requires looking back in the list of parents by the depth of the quote
** will probably ignore errorneous quote depth
* the post’s HTML could contain the whole thread of the post below the
post itself?
** this would break our rule of dependencies; see Architecture
&lt;&lt;&lt;!link&gt;&gt;&gt;
* pre-references to yet non-existing posts
** this is detailed in another post
&lt;&lt;&lt;!link&gt;&gt;&gt;
* hide known metas unless otherwise noted
** probably an option
* show unknown metas specifically
** probably an option

Other ideas:
* the name of authors, and authors' names quoted should be totally ignored
** I long sticked to my habit of keeping others quoted names in posts
** this turned out to be a bad decision, since the names of current
and previous authors are stored on the Heap
&lt;&lt;&lt;!link Hcs already warned me months ago, link it here.&gt;&gt;&gt;
** so, instead of cleaning up manually, let's just make Hk immune to
this dated style
* similarly, Hk could ignore email-ish quote introduction lines (e.g.
Xyz &lt;x@y.z&gt; wrote:)
* perhaps integrate with Wiko? enable
** already discussed
&lt;&lt;&lt;!link&gt;&gt;&gt;
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/179 -->
<span class="postsummary" id="post_hh/179">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/179">&lt;hh/179&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/156">&lt;&uarr;hh/156&gt;</a></span>
<span class="date">(2009-05-08)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; == The What ==

</span></span>It would be very nice to read the concepts of the "what". This is only
a bunch of features that we want to implement.

I mean concepts like this:
- A meta text is something starting with "^&lt;&lt;&lt;" and finishing with
  "&gt;&gt;&gt;$" or EOF.
- The first word of the meta text special.
  a. If it starts with an exclamation mark, it is a command. The
     commands are executed under the supervision of a heap maintainer.
     Examples:
     - !delpost
     - !delthis
  b. If it does not start with an exclamation mark, it is the type of
     the meta text. This specifies how the meta text should be
     displayed.
     - todo

I'm tempted to write more, but I think it is your job :) I wrote an
email about this to the UMS heap, but we need a more organized one
now. I will spend my time improving something else on Hk (or on hh )
instead.
</pre></div>
</span><!-- postsummary -->
</div><!-- postbox for post hh/179 -->

<div class="postbox"><!-- post hh/186 -->
<span class="postsummary" id="post_hh/186">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/186">&lt;hh/186&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/156">&lt;&uarr;hh/156&gt;</a></span>
<span class="date">(2009-05-09)</span>
<div class="body">
<pre class="postbody">== The When ==

An important addition to what should happen is when exactly should it happen.
That is, besides specifying the exact steps that must take place during body
parsing, we also have to decide when to invoke the processing.

Candidates (the possible times of invocation):
* during creation of PostDB, when post has been loaded from the disk
* during downloading from the IMAP server
* during generation of HTML output

Note that the first two can be handled at the same time if we do the parsing
during the init of the Post objects.
</pre></div>
</span><!-- postsummary -->
</div><!-- postbox for post hh/186 -->

<div class="postbox"><!-- post hh/232 -->
<span class="postsummary" id="post_hh/232">
<span class="author">Attila Nagy</span>
<span class="subject">Body parsing - the what - examples</span>
<span class="index"><a href="../hh/thread_156.html#post_hh/232">&lt;hh/232&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/156">&lt;&uarr;hh/156&gt;</a></span>
<span class="date">(2009-05-18)</span>
<div class="body">
<pre class="postbody">The first parser module takes the plaintext body of the message, and turn it
into a sequence of plaintext segments. Further modules then transform these
segments, usually transforming some of them into other, more specific and
interpreted segments. This process is shown here with examples.

== Rendering URLs as links ==

Plaintext body:

    Hello everybody.

    Look what I found:

    <a href="http://www.url.com">http://www.url.com</a>

    For more details, see <a href="http://www.example.com">http://www.example.com</a> too.

Initial segmenting:

    Plaintext [Hello everybody.]
    Boundary  []
    Plaintext [Look what I found.]
    Boundary  []
    Plaintext [<a href="http://www.url.com]">http://www.url.com]</a>
    Boundary  []
    Plaintext [For more details, see <a href="http://www.example.com">http://www.example.com</a> too.]

After URL interpretation:

    Plaintext [Hello everybody.]
    Boundary  []
    Plaintext [Look what I found.]
    Boundary  []
    URL       [<a href="http://www.url.com]">http://www.url.com]</a>
    Boundary  []
    Plaintext [For more details, see]
    URL       [<a href="http://www.example.com]">http://www.example.com]</a>
    Plaintext [ too.]

This is now rendered in HTML like this:

    &lt;p&gt;
        Hello everybody.
    &lt;/p&gt;
    &lt;p&gt;
        Look what I found.
    &lt;/p&gt;
    &lt;a href="<a href="http://www.url.com%22>">http://www.url.com"&gt;</a>
        <a href="http://www.url.com">http://www.url.com</a>
    &lt;/a&gt;
    &lt;p&gt;
        For more details, see
        &lt;a href="<a href="http://www.url.com%22>">http://www.url.com"&gt;</a>
            <a href="http://www.url.com">http://www.url.com</a>
        &lt;/a&gt;
         too.
    &lt;/p&gt;

=== Special protocols ===

Some protocol specifiers, like "http", "https", "ftp" and "file", are passed on
to the HTML output unchanged. Others' have meanings internal to Heapkeeper and
make no sense to the browser; these exist as a convenience feature for
referring to other posts on the heap.

We have used the "heap" protocol to refer to other messages, as in:

    In another post [1], you...

    [1] heap://1234

It may also be useful to refer to posts on different heaps in a similar
fashion, like:

    I've already discussed this at length on the internal heap [2].

    [2] heap://internal/567

Of course, we have to provide the URL of the mentioned internal heap
for this to work.

=== Link appearance ===

There has been request for a mechanism to alter the way the inline links
appear. No syntax has been agreed on for this; an example follows to illustrate
the idea:

Plaintext:

    Please have a look at &lt;&lt;&lt;link <a href="http://www.example.com">http://www.example.com</a> this site&gt;&gt;&gt;.

HTML rendering:

    &lt;p&gt;
        Please have a look at
        &lt;a href="<a href="http://www.example.com%22>">http://www.example.com"&gt;</a>
            this site
        &lt;/a&gt;
        .
    &lt;/p&gt;

== Render post metas as links ==

"Post metas" are a mechanism to add links to other posts on the heap without
using a cite.

Plaintext body:

    I've already written about this in &lt;&lt;&lt;post 234&gt;&gt;&gt;.

Initial segmentation:

    Plaintext [I've already written about this in &lt;&lt;&lt;post 234&gt;&gt;&gt;.]


After processing post metas:

    Plaintext [I've already written about this in ]
    Postlink  [234]
    Plaintext [.]

A possible HTML rendering:

    &lt;p&gt;
        I've already written about this in
        &lt;a href="234.html"&gt;
            &lt;&lt;&lt;post 234&gt;&gt;&gt;
        &lt;/a&gt;
        .
    &lt;/p&gt;

Note: this feature can be used to achieve the same results as with the "heap"
protocol specifier.

== Automatically add tags based on metas ==

This was formerly part of the proposal, but now its usefulness has been
doubted, as it breaks the principle of avoiding redundance in postfiles.

== Cites ==

Cites are a way to include details, explanation or external sources in the post
without distracting the reader's attention unnecessarily. In the flowing text,
cites appear as decimal numbers in brackets, while at the end of the post they
are expanded (usually, but the expansions can be anywhere).

Plaintext body:

    This site [1] says that it's not important [2].

    [1] <a href="http://www.boring.com">http://www.boring.com</a>
    [2] At least that's what they say...

After initial segmenting:

    Plaintext [This site [1] says that it's not important. [2]]
    Boundary  []
    Plaintext [[1] <a href="http://www.boring.com\n[2]">http://www.boring.com\n[2]</a> At least that's what they say...]

After processing cites:

    Paragraph [This site ]
    Citehead  [1]
    Paragraph [says that it's not important. ]
    Citehead  [2]
    CitebodyURL   [1 <a href="http://www.boring.com]">http://www.boring.com]</a>
    CitebodyText  [2 At least that's what they say...]

HTML output:

    &lt;p&gt;
        This site
        &lt;a href="<a href="http://www.boring.com%22">http://www.boring.com"</a> class="external"&gt;
            [1]
        &lt;/a&gt;
        says that it's not important.
        &lt;a href="#cite-2" class="internal"&gt;
            [2]
        &lt;/a&gt;
    &lt;p&gt;
    &lt;p class="citebody" id="cite-1"&gt;
        [1] <a href="http://www.boring.com">http://www.boring.com</a>
    &lt;/p&gt;
    &lt;p class="citebody" id="cite-2"&gt;
        [2] At least that's what they say...
    &lt;/p&gt;

The different classes for the link enable the CSS to visually distinguish links
that'll move away from the page from links that'll only jump inside the page.

== Automatic action on metas (a.k.a. !-metas) ==

This feature allows the author of a post to prescribe actions to be executed
from within hkshell. The range of these automatic commands has been discussed
at length, due to the obvious security consequences of malicious (or even
errorneous) usage.

Therefore, our present plans do not contain a fully automatic execution of
code coming from posts, but a semi-automatic scheme instead. Instructions
in posts do not get executed right away, but only when the editor issues
a special command in hkshell, the ``run()`` command. When this command
is issued, commands embedded in metas are listed and for each of them,
the editor is asked if it is safe to execute the command in question.

The metas that prescribe some kind of command to be executed semi-automatically
begin with an '!'. Hence, they are commonly called !-metas.

The precise list of the !-metas is not yet final, some are presumably
very close to their final forms. These are the most simple !-metas:
their scope is only themselves or the post they contain.

* &lt;&lt;&lt;!deltext&gt;&gt;&gt; - delete this meta
** used to give throwaway hints to the
* &lt;&lt;&lt;!delpost&gt;&gt;&gt; - delete this entire post
** this is used to mark the post as being entirely for the eyes of the
editor or a remark to e-mail readers only, with no historical interest
* &lt;&lt;&lt;!delthis&gt;&gt;&gt; - an obsolete, ambiguous form

An example in plaintext:

    OK. I'll write more on the details this weekend.

    &lt;&lt;&lt;!delpost&gt;&gt;&gt;

Initial segmenting:

    Plaintext [OK. I'll write more on the details this weekend.]

    Separator []

    Plaintext [&lt;&lt;&lt;!delpost&gt;&gt;&gt;]

After processing !-metas:

    Paragraph [OK. I'll write more on the details this weekend.]

    Separator []

    DelpostMeta []

Which could be rendered in HTML as:

    &lt;p&gt;
        OK. I'll write more on the details this weekend.
    &lt;/p&gt;
    &lt;p class="warning"&gt;
        The author of this post asked the editor to delete it.
    &lt;/p&gt;

I think it's better to display these metas in the output to serve as
an extra reminder to the editor to act on the !-meta: run it or remove
it.

Now if the editor sees this, and launches hkshell:

    $ ./hkshell
    Importing hkrc...
    Importing hkrc OK
    1 operation requested.
    &gt;&gt;&gt; run()
    Post 234 requests: delete post
    Do you comply [yn]? y
    Post 234 deleted.
    &gt;&gt;&gt; s();ga();q()

== Quotes ==

Finding quotes is important for two reasons. Firstly, collecting quoted
parts of the body into specific HTML elements allows for styling them
via CSS, which may be more readily recognizable than quote introduction
characters (&gt;) alone.

Secondly, the program can use the thread structure and quotation depth
together to find the original author of the quoted lines. Quote
introduction lines could be parsed and used in determining the authors
or could simply be thrown away.

This raises its own problems. When quoting, the author of the post
may have quoted from other posts than the one xe is answering [1],
or the thread structure could be modified on the Heap without updating
the quote depths. Quote introduction lines of the form

    Attis wrote:
    &gt; I have the strange feeling this line will get quoted.

These have language issues, since some user agents include them
automatically. Suppose I am on a holiday in France, and my addiction
forces me to go into a netcafé and write to the Heap.

    Csabi a écrit:
    &gt; Where are you now?

    I'm in France.

Of course, no-one can expect Hk to be able to parse these quote
introduction in all languages of the world. (My example seems
contrived, but anyone who has read international mailing lists know
that this is an issue.)

The other problem with these lines is that many of them have fallen prey
to my zealous tidying efforts... of course, Git remembers, but it'd be
a pretty daunting homework of necromancy to bring them all back.

A more general example follows:

Plaintext body:

    &gt;&gt;&gt; We should use Ratpoison.
    &gt;&gt;
    &gt;&gt; What is ratpoison?
    &gt;
    &gt; Ratpoison is a minimalistic window manager.

    Why do you think we all should use it?

Initial segmenting:

    Plaintext [&gt;&gt;&gt; We should use Ratpoison.\n
    &gt;&gt;\n
    &gt;&gt; What is ratpoison?\n
    &gt;\n
    &gt; Ratpoison is a minimalistic window manager.]

    Boundary  []

    Plaintext [Why do you think we all should use it?]

After quote expansion, pass 1:

    Quote     [

        Quote   [&gt;&gt; We should use Ratpoison.\n
                &gt;\n
                &gt; What is ratpoison?\n]

        Boundary    []

        Paragraph   [Ratpoison is a minimalistic window manager.]
        ]

    Boundary  []

    Paragraph [Why do you think we all should use it?]

After quote expansion, pass 2:

    Quote     [

        Quote   [

            Quote [We should use Ratpoison.]

            Boundary    []

            Plaintext [What is ratpoison?]
            ]

        Boundary    []

        Plaintext   [Ratpoison is a minimalistic window manager.]
        ]

    Boundary  []

    Plaintext [Why do you think we all should use it?]

HTML output:

    &lt;p class="quote"&gt;
        &lt;p class="quoteauthor"&gt;
            Attis
        &lt;/p&gt;
        &lt;p class="quote"&gt;
            &lt;p class="quoteauthor"&gt;
                Csabi
            &lt;/p&gt;
            &lt;p class="quote"&gt;
                &lt;p class="quoteauthor"&gt;
                    Attis
                &lt;/p&gt;
                We should use Ratpoison.
            &lt;/p&gt;
            &lt;p&gt;
                What is Ratpoison?
            &lt;/p&gt;
        &lt;/p&gt;
        &lt;p&gt;
            Ratpoison is a minimalistic window manager.
        &lt;/p&gt;
    &lt;/p&gt;
    &lt;p&gt;
        Why do you think we all should use it?
    &lt;/p&gt;

This means that once we have a Quote segment, the following actions
shall take place:

* Strip the leading &gt;'s.
* Launch the whole body parsing procedure on the contents of the Quote
segment.
* Add all resulting segments to the Quote segment as sub-segments.

When processing Quote segments, all modules should use recursion if
they are applicable to quoted text. For example, when finding URLs,
the module should enumerate Quotes' contents recursively, and then find
URLs inside segments contained within the Quote structure.

== Note metas ==

Note metas contain information that are mainly for historical
reference, but are out of the context of the text. They are metatext
of the purest sense of the word, and the source of the whole idea of
metas.

Plaintext:

    This idea is most likely to serve as an inexhaustable source of
    inspiration for many generations to come.

    &lt;&lt;&lt;note Watch the wording, I must have been high.&gt;&gt;&gt;

Initial segmentation:

    Plaintext [This idea is most likely to serve as an inexhaustable
    source of\ninspiration for many generations to come.]

    Boundary  []

    Plaintext [&lt;&lt;&lt;note Watch the wording, I must have been high.&gt;&gt;&gt;]

After processing note metas:

    Paragraph [This idea is most likely to serve as an inexhaustable
    source of inspiration for many generations to come.]

    Boundary  []

    Note      [Watch the wording, I must have been high.]

HTML output:

    &lt;p&gt;
        This idea is most likely to serve as an inexhaustable source
        of inspiration for many generations to come.
    &lt;/p&gt;
    &lt;p class="note"&gt;
        Watch the wording, I must have been high.]
    &lt;/p&gt;

== Unknown metas ==

I think unknown metas should be displayed specially, as they require
attention from an editor.

Plaintext:

    This needs more explanation.

    &lt;&lt;&lt;!delpots&gt;&gt;&gt;

Initial segmenting:

    Plaintext [This needs more explanation.]

    Boundary  []

    Plaintext [&lt;&lt;&lt;!delpots&gt;&gt;&gt;]

After processing unknown metas:

    Paragraph [This needs more explanation.]

    Boundary  []

    UnknownMeta[!delpots]

HTML rendering:

    &lt;p&gt;
        This needs more explanation.
    &lt;/p&gt;
    &lt;p class="warning"&gt;
        Unknown meta in post: "delpots".
    &lt;/p&gt;

== Authors and signatures ==

If a line matches entirely with an author's known and stored nickname,
it should be ignored. But, regardless of whether a signature line
is present, a signature should be added in the HTML rendering

Plaintext:

    Thank you for reading all this.

    Attis

Initial segmenting:

    Plaintext [Thank you for reading all this.]

    Boundary  []

    Plaintext [Attis]

After removing signatures:

    Paragraph [Thank you for reading all this.]

HTML output:

    &lt;p&gt;
        Thank you for reading all this.
    &lt;/p&gt;
    &lt;p class="signature"&gt;
        Attis
    &lt;/p&gt;

== Wiki-like headers ==

The idea of MediaWiki-like syntax for headers has been proposed (and
this post happens to follow this syntax :)). This feature is enabled
only if the &lt;&lt;&lt;wiki&gt;&gt;&gt; meta is present.

Plaintext:

    &lt;&lt;&lt;wiki&gt;&gt;&gt;
    == Bacteria ==

    Bacteria are the most simple cellular organisms.

Initial segmenting:

    Plaintext [&lt;&lt;&lt;wiki&gt;&gt;&gt;\n== Bacteria ==]

    Boundary  []

    Plaintext [Bacteria are the most simple cellular organisms.]

After header processing:

    WikiMeta  []

    Heading1  [Bacteria]

    Boundary  []

    Paragraph [Bacteria are the most simple cellular organisms.]

HTML output:

    &lt;h1&gt;
        Bacteria
    &lt;/h1&gt;
    &lt;p&gt;
        Bacteria are the most simple cellular organisms.
    &lt;/p&gt;


== TODO ==

There are probably many other things that the body parser should do. I
think none of these have a consequence that will change the
architecture of body parsing. If you know of any, please post it here.


[1] This is the kind of structure where singular they is simply too
awkward.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/246 -->
<span class="postsummary" id="post_hh/246">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/246">&lt;hh/246&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/232">&lt;&uarr;hh/232&gt;</a></span>
<span class="date">(2009-05-19)</span>
<div class="body">
<pre class="postbody">This page should be a wiki page on the heap. (See this thread [1]
about wiki pages on the heap.) Thus I've posted a todo about every
typo. I agree with everything I haven't commented.

<span class="quote"><span class="quote-1">&gt; The first parser module takes the plaintext body of the message, and
&gt; turn it

</span></span>&lt;&lt;&lt;todo: turn -&gt; turns&gt;&gt;&gt;

<span class="quote"><span class="quote-1">&gt; into a sequence of plaintext segments.

&gt; Initial segmenting:
&gt;
&gt;    Plaintext [Hello everybody.]
&gt;    Boundary  []
&gt;    Plaintext [Look what I found.]
&gt;    Boundary  []
&gt;    Plaintext [</span></span><span class="quote"><span class="quote-1"><a href="http://www.url.com]">http://www.url.com]</a></span></span><span class="quote"><span class="quote-1">
&gt;    Boundary  []
&gt;    Plaintext [For more details, see </span></span><span class="quote"><span class="quote-1"><a href="http://www.example.com">http://www.example.com</a></span></span><span class="quote"><span class="quote-1"> too.]
&gt;
&gt; After URL interpretation:
&gt;
&gt;    Plaintext [Hello everybody.]
&gt;    Boundary  []
&gt;    Plaintext [Look what I found.]
&gt;    Boundary  []
&gt;    URL       [</span></span><span class="quote"><span class="quote-1"><a href="http://www.url.com]">http://www.url.com]</a></span></span><span class="quote"><span class="quote-1">
&gt;    Boundary  []
&gt;    Plaintext [For more details, see]

</span></span>&lt;&lt;&lt;todo: "see]" -&gt; "see ]", right? I guess it will not matter in the
later stages, but still.&gt;&gt;&gt;

<span class="quote"><span class="quote-1">&gt; === Special protocols ===
&gt;
&gt; Some protocol specifiers, like "http", "https", "ftp" and "file",
&gt; are passed on to the HTML output unchanged. Others' have meanings

</span></span>&lt;&lt;&lt;todo Is the apostrophe at the "Others'" an error?&gt;&gt;&gt;

== Place of meta text ==

<span class="quote"><span class="quote-1">&gt; === Link appearance ===
&gt;
&gt; [...]
&gt;
&gt; Plaintext:
&gt;
&gt;    Please have a look at &lt;&lt;&lt;link </span></span><span class="quote"><span class="quote-1"><a href="http://www.example.com">http://www.example.com</a></span></span><span class="quote"><span class="quote-1"> this site&gt;&gt;&gt;.

</span></span>Previously we agreed on allowing the &lt;&lt;&lt; and &gt;&gt;&gt; of the meta text only
in the beginning of the lines [2]. Have you changed your mind about
this?

== Cites ==

<span class="quote"><span class="quote-1">&gt; Cites are a way to include details, explanation or external sources
&gt; in the post without distracting the reader's attention
&gt; unnecessarily. In the flowing text, cites appear as decimal numbers
&gt; in brackets, while at the end of the post they are expanded
&gt; (usually, but the expansions can be anywhere).
&gt;
&gt; Plaintext body:
&gt;
&gt;    This site [1] says that it's not important [2].
&gt;
&gt;    [1] </span></span><span class="quote"><span class="quote-1"><a href="http://www.boring.com">http://www.boring.com</a></span></span><span class="quote"><span class="quote-1">
&gt;    [2] At least that's what they say...
&gt;
&gt; After initial segmenting:
&gt;
&gt;    Plaintext [This site [1] says that it's not important. [2]]
&gt;    Boundary  []
&gt;    Plaintext [[1] </span></span><span class="quote"><span class="quote-1"><a href="http://www.boring.com\n[2]">http://www.boring.com\n[2]</a></span></span><span class="quote"><span class="quote-1"> At least that's what they say...]
&gt;
&gt; After processing cites:
&gt;
&gt;    Paragraph [This site ]
&gt;    Citehead  [1]
&gt;    Paragraph [says that it's not important. ]
&gt;    Citehead  [2]
&gt;    CitebodyURL   [1 </span></span><span class="quote"><span class="quote-1"><a href="http://www.boring.com]">http://www.boring.com]</a></span></span><span class="quote"><span class="quote-1">
&gt;    CitebodyText  [2 At least that's what they say...]
&gt;
&gt; HTML output:
&gt;
&gt;    &lt;p&gt;
&gt;        This site
&gt;        &lt;a href="</span></span><span class="quote"><span class="quote-1"><a href="http://www.boring.com%22">http://www.boring.com"</a></span></span><span class="quote"><span class="quote-1"> class="external"&gt;
&gt;            [1]
&gt;        &lt;/a&gt;
&gt;        says that it's not important.
&gt;        &lt;a href="#cite-2" class="internal"&gt;
&gt;            [2]
&gt;        &lt;/a&gt;
&gt;    &lt;p&gt;
&gt;    &lt;p class="citebody" id="cite-1"&gt;
&gt;        [1] </span></span><span class="quote"><span class="quote-1"><a href="http://www.boring.com">http://www.boring.com</a></span></span><span class="quote"><span class="quote-1">
&gt;    &lt;/p&gt;
&gt;    &lt;p class="citebody" id="cite-2"&gt;
&gt;        [2] At least that's what they say...
&gt;    &lt;/p&gt;
&gt;
&gt; The different classes for the link enable the CSS to visually
&gt; distinguish links that'll move away from the page from links that'll
&gt; only jump inside the page.

</span></span>I would also like to write emails like this:

   Our website [1] should be improved according to them [2].

   [1] Currently <a href="http://hste.uw.hu/heapkeeper/index.html">http://hste.uw.hu/heapkeeper/index.html</a>
   [2] <a href="http://www.boring.org">http://www.boring.org</a>, section "Heapkeeper is boring"

== Automatic action on metas (a.k.a. !-metas) ==

<span class="quote"><span class="quote-1">&gt; * &lt;&lt;&lt;!deltext&gt;&gt;&gt; - delete this meta
&gt; ** used to give throwaway hints to the

</span></span>&lt;&lt;&lt;todo I think this sentence is unfinished.&gt;&gt;&gt;

== Quotes ==

<span class="quote"><span class="quote-1">&gt; Finding quotes is important for two reasons. Firstly, collecting quoted
&gt; parts of the body into specific HTML elements allows for styling them
&gt; via CSS, which may be more readily recognizable than quote introduction
&gt; characters (&gt;) alone.
&gt;
&gt; Secondly, the program can use the thread structure and quotation depth
&gt; together to find the original author of the quoted lines. Quote
&gt; introduction lines could be parsed and used in determining the authors
&gt; or could simply be thrown away.

</span></span>A third reason is to process quotes differently: e.g. we don't want to
interpret cite heads in quotes.

<span class="quote"><span class="quote-1">&gt; After quote expansion, pass 2:
&gt;
&gt;    Quote     [
&gt;
&gt;        Quote   [
&gt;
&gt;            Quote [We should use Ratpoison.]
&gt;
&gt;            Boundary    []
&gt;
&gt;            Plaintext [What is ratpoison?]
&gt;            ]
&gt;
&gt;        Boundary    []
&gt;
&gt;        Plaintext   [Ratpoison is a minimalistic window manager.]
&gt;        ]
&gt;
&gt;    Boundary  []

</span></span>Are you sure this recursive structure is the best one?

The following structure seems to be better for me:

    Quote,3   [We should use Ratpoison.]
    Quote,2   [What is ratpoison?]
    Quote,1   [Ratpoison is a minimalistic window manager.]
    Boundary  []
    Plaintext [Why do you think we all should use it?]

I think from the parser's point of view the two approaches need equal
amount of work. From the HTML presentation's point of view, yours is
probably easier. From the point of view of all the other processors,
though, I think my approach is simpler.

<span class="quote"><span class="quote-1">&gt;    &lt;p class="note"&gt;
&gt;        Watch the wording, I must have been high.]
&gt;    &lt;/p&gt;

</span></span>&lt;&lt;&lt;todo Remove the ] from the last but one line.&gt;&gt;&gt;

== Unknown metas ==

<span class="quote"><span class="quote-1">&gt; I think unknown metas should be displayed specially, as they require
&gt; attention from an editor.

</span></span>I agree.

== Authors and signatures ==

<span class="quote"><span class="quote-1">&gt; If a line matches entirely with an author's known and stored nickname,
&gt; it should be ignored.

</span></span>Why?

<span class="quote"><span class="quote-1">&gt; But, regardless of whether a signature line is present, a signature
&gt; should be added in the HTML rendering

</span></span>&lt;&lt;&lt;todo Period is missing&gt;&gt;&gt;

OK. I don't see the use of this, but if you like it, go ahead.

== Wiki-like headers ==

<span class="quote"><span class="quote-1">&gt; The idea of MediaWiki-like syntax for headers has been proposed (and
&gt; this post happens to follow this syntax :)). This feature is enabled
&gt; only if the &lt;&lt;&lt;wiki&gt;&gt;&gt; meta is present.
&gt;
&gt; Plaintext:
&gt;
&gt;    &lt;&lt;&lt;wiki&gt;&gt;&gt;
&gt;    == Bacteria ==
&gt;
&gt;    Bacteria are the most simple cellular organisms.
&gt;
&gt; Initial segmenting:
&gt;
&gt;    Plaintext [&lt;&lt;&lt;wiki&gt;&gt;&gt;\n== Bacteria ==]

</span></span>I don't know how do you think the parser will work, but I would think
it never creates that text. It is highly illogical to me that our main
text object is the TeX-like paragraph, and everything else is parsed
from those. Consider this:

    &lt;&lt;&lt;note

    This is a long note.

    Eh.&gt;&gt;&gt;

In my opinion we can create the following text objects in first go:
- quote blocks
- meta text blocks
- text blocks
- raw blocks (lines that start with whitespace and would be in a text
  block otherwise)

The first go takes into account only the first few characters of each
line.

We can create these in the second go:
- quote paragraphs
- text paragraphs

In case of the wiki syntax, another go would happen between the first
and the second ones: the one that creates the headers.

== TODO ==

<span class="quote"><span class="quote-1">&gt; There are probably many other things that the body parser should do. I
&gt; think none of these have a consequence that will change the
&gt; architecture of body parsing. If you know of any, please post it here.

</span></span>I just posted one :)

=== Itemization ===

And here is another one. I write itemizations very frequently. Like
these:

    Nice animals:
    - cat
    - dog
    - fish

    We could do:
    a. this
    b. that

    If we choose (a), we have to:
    1. start
    2. stop

We have to find a way to render these. (I haven't found yet.)

Csabi

[1] <a href="../hh/thread_4.html#post_hh/4">heap://hh/4</a>
[2] heap://ums/1176
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/301 -->
<span class="postsummary" id="post_hh/301">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/301">&lt;hh/301&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/246">&lt;&uarr;hh/246&gt;</a></span>
<span class="date">(2009-05-21)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; This page should be a wiki page on the heap. (See this thread [1]
&gt; about wiki pages on the heap.) Thus I've posted a todo about every
&gt; typo. I agree with everything I haven't commented.

</span></span>OK. Here, I'll comment on those comments that are questions or the
ones I don't agree. I accept all the others.

=== Special protocols ===

<span class="quote"><span class="quote-2">&gt;&gt; Some protocol specifiers, like "http", "https", "ftp" and "file",
&gt;&gt; are passed on to the HTML output unchanged. Others' have meanings
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; &lt;&lt;&lt;todo Is the apostrophe at the "Others'" an error?&gt;&gt;&gt;

</span></span>Yes.


== Place of meta text ==

=== Link appearance ===

<span class="quote"><span class="quote-2">&gt;&gt;    Please have a look at &lt;&lt;&lt;link </span></span><span class="quote"><span class="quote-2"><a href="http://www.example.com">http://www.example.com</a></span></span><span class="quote"><span class="quote-2"> this site&gt;&gt;&gt;.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Previously we agreed on allowing the &lt;&lt;&lt; and &gt;&gt;&gt; of the meta text only
&gt; in the beginning of the lines [2]. Have you changed your mind about
&gt; this?

</span></span>No, not at all. But of course this feature is so "inline" that it'd
almost ruin its usability if we'd have to write it in a new line. Of
course I don't want to change the convention regarding the start of
metas, mainly for performance considerations. How about adopting
MediaWiki's solution instead? Thus, this example would look like:

    Please have a look at [<a href="http://www.example.com">http://www.example.com</a> this site].

I think this would be the most convenient and less obtrusive solution.

== Cites ==

My proposition only provided two kind of cites. One cites an URL and
nothing else; the inline headers link right to the URL in this case.
The other adds some kind of explanation or comment, and for these, the
inline header link merely jumps to the body of the cite.

<span class="quote"><span class="quote-2">&gt;&gt; The different classes for the link enable the CSS to visually
&gt;&gt; distinguish links that'll move away from the page from links that'll
&gt;&gt; only jump inside the page.

</span></span><span class="quote"><span class="quote-1">&gt; I would also like to write emails like this:
&gt;
&gt;   Our website [1] should be improved according to them [2].
&gt;
&gt;   [1] Currently </span></span><span class="quote"><span class="quote-1"><a href="http://hste.uw.hu/heapkeeper/index.html">http://hste.uw.hu/heapkeeper/index.html</a></span></span><span class="quote"><span class="quote-1">
&gt;   [2] </span></span><span class="quote"><span class="quote-1"><a href="http://www.boring.org">http://www.boring.org</a></span></span><span class="quote"><span class="quote-1">, section "Heapkeeper is boring"

</span></span>Now, if I understand you correctly, you would also like to handle
those cites that fall into neither of these, namely, the ones which
contain both an URL and a textual comment. The question is, of course,
how should we handle these? Would the head link to the body, or right
to the URL contained in the body (assuming, of course, that there's
only one URI in the body!)

== Automatic action on metas (a.k.a. !-metas) ==

<span class="quote"><span class="quote-2">&gt;&gt; * &lt;&lt;&lt;!deltext&gt;&gt;&gt; - delete this meta
&gt;&gt; ** used to give throwaway hints to the
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; &lt;&lt;&lt;todo I think this sentence is unfinished.&gt;&gt;&gt;

</span></span>It should be "used to give throwaway hints to the maintainer of the
heap or pass information that is only important to the readers of the
original e-mail".

== Quotes ==

<span class="quote"><span class="quote-2">&gt;&gt; Finding quotes is important for two reasons. Firstly, collecting quoted
&gt;&gt; parts of the body into specific HTML elements allows for styling them
&gt;&gt; via CSS, which may be more readily recognizable than quote introduction
&gt;&gt; characters (&gt;) alone.
&gt;&gt;
&gt;&gt; Secondly, the program can use the thread structure and quotation depth
&gt;&gt; together to find the original author of the quoted lines. Quote
&gt;&gt; introduction lines could be parsed and used in determining the authors
&gt;&gt; or could simply be thrown away.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; A third reason is to process quotes differently: e.g. we don't want to
&gt; interpret cite heads in quotes.

</span></span>We could interpret cite heads in quotes, but it would probably not be
worth the effort.

<span class="quote"><span class="quote-1">&gt; Are you sure this recursive structure is the best one?

</span></span>No, not at all. We should have a discussion dedicated solely to this
matter, maybe on Skype or IRC?

<span class="quote"><span class="quote-1">&gt; I think from the parser's point of view the two approaches need equal
&gt; amount of work. From the HTML presentation's point of view, yours is
&gt; probably easier. From the point of view of all the other processors,
&gt; though, I think my approach is simpler.

</span></span>This point also needs to be clarified, and I'm really eager to hear
about your ideas. This, I think, is one of the most difficult matters
in body parsing.

== Authors and signatures ==

<span class="quote"><span class="quote-2">&gt;&gt; If a line matches entirely with an author's known and stored nickname,
&gt;&gt; it should be ignored.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Why?

</span></span>I've been omitting the signature from my posts from some time now. We
don't have to sign our mails since the body parser can put the
signature there automatically when displaying the post. But to avoid
having two signatures, we should ignore the signatures already
present. An equivalently viable approach would be to output the
generated signature only if there is the body itself does not contain
a signature.

== Wiki-like headers ==

<span class="quote"><span class="quote-2">&gt;&gt; Plaintext:
&gt;&gt;
&gt;&gt;    &lt;&lt;&lt;wiki&gt;&gt;&gt;
&gt;&gt;    == Bacteria ==
&gt;&gt;
&gt;&gt; Initial segmenting:
&gt;&gt;
&gt;&gt;    Plaintext [&lt;&lt;&lt;wiki&gt;&gt;&gt;\n== Bacteria ==]
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; I don't know how do you think the parser will work, but I would think
&gt; it never creates that text. It is highly illogical to me that our main
&gt; text object is the TeX-like paragraph, and everything else is parsed
&gt; from those. Consider this:
&gt;
&gt;    &lt;&lt;&lt;note
&gt;
&gt;    This is a long note.
&gt;
&gt;    Eh.&gt;&gt;&gt;
&gt;
&gt; In my opinion we can create the following text objects in first go:
&gt; - quote blocks
&gt; - meta text blocks
&gt; - text blocks
&gt; - raw blocks (lines that start with whitespace and would be in a text
&gt;  block otherwise)

</span></span>In general, I like the idea, but it seems to conflict with the idea of
modularity. If we hardwire these in the Dissector (in the current
implementation, this is the name of the module that creates the
initial segmentation), the module to process, say, quotes will not be
turned off by simply not loading its module into the parser framework.
Adding a new kind of object will not be impossible, though, only we
have to find them in the initial segments. Maybe the Dissector could
be customized: by default, it'd create all the text object you've
mentioned, but they could be turned off individually.

<span class="quote"><span class="quote-1">&gt; The first go takes into account only the first few characters of each
&gt; line.

</span></span>Yes, this would be very important. Right now, parsing only the headers
is quite a task, with only ~2000 posts. Imagine what happens if the
whole body will be parsed!

<span class="quote"><span class="quote-1">&gt; We can create these in the second go:
&gt; - quote paragraphs
&gt; - text paragraphs
&gt;
&gt; In case of the wiki syntax, another go would happen between the first
&gt; and the second ones: the one that creates the headers.

</span></span>OK.

=== Itemization ===

<span class="quote"><span class="quote-1">&gt; And here is another one. I write itemizations very frequently. Like
&gt; these:
&gt;
&gt;    Nice animals:
&gt;    - cat
&gt;    - dog
&gt;    - fish
&gt;
&gt;    We could do:
&gt;    a. this
&gt;    b. that
&gt;
&gt;    If we choose (a), we have to:
&gt;    1. start
&gt;    2. stop
&gt;
&gt; We have to find a way to render these. (I haven't found yet.)

</span></span>This is another important issue. I've also thought about them. I this
topic would also have to be included into our consultation.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/308 -->
<span class="postsummary" id="post_hh/308">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/308">&lt;hh/308&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/301">&lt;&uarr;hh/301&gt;</a></span>
<span class="date">(2009-05-23)</span>
<div class="body">
<pre class="postbody">== Place of meta text ==

=== Link appearance ===

<span class="quote"><span class="quote-3">&gt;&gt;&gt;    Please have a look at &lt;&lt;&lt;link </span></span><span class="quote"><span class="quote-3"><a href="http://www.example.com">http://www.example.com</a></span></span><span class="quote"><span class="quote-3"> this site&gt;&gt;&gt;.
</span></span><span class="quote"><span class="quote-2">&gt;&gt; Previously we agreed on allowing the &lt;&lt;&lt; and &gt;&gt;&gt; of the meta text only
&gt;&gt; in the beginning of the lines [2]. Have you changed your mind about
&gt;&gt; this?
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; No, not at all. But of course this feature is so "inline" that it'd
&gt; almost ruin its usability if we'd have to write it in a new line. Of
&gt; course I don't want to change the convention regarding the start of
&gt; metas, mainly for performance considerations. How about adopting
&gt; MediaWiki's solution instead? Thus, this example would look like:
&gt;
&gt;     Please have a look at [</span></span><span class="quote"><span class="quote-1"><a href="http://www.example.com">http://www.example.com</a></span></span><span class="quote"><span class="quote-1"> this site].
&gt;
&gt; I think this would be the most convenient and less obtrusive solution.

</span></span>But then how would be define when is "[" special and when not? It
seems to be a daunting task... Except if we say "[" is always special
in a non-raw text. But then we won't need "&lt;&lt;&lt;" -- its role can be
merged into the role of "[". I thought about this a lot, and I make a
proposal. But first, motivation.

== Basic principle of post syntax and semantics ==

Backward compatibility of post syntax and semantics is a very
important issue. Otherwise people will always have to modify the posts
sitting on their heaps in order to comply the latest post syntax.
That's not convenient for hobby users, but much more worse for
institutional users.

Thus I formulate a basic principle which makes backward compatibility
not so difficult to achieve. The basic principle of creating the
syntax and semantics of posts should be the following. We have to make
an initial ruleset that states clearly what is a syntactically and
semantically correct post. The syntax and semantics of those posts
should _never_ change. The way we can add more features: we change the
ruleset so that posts there were previously syntactically or
semantically incorrect will become correct. These posts refer to new
features that were introduced with the change of the ruleset. The post
syntax/semantics can evolve continuously, as we turn more and more
previously incorrect posts to correct ones. Of course we will never
run out of incorrect posts -- they are infinite in number.

=== Note about programming languages ===

This is the way how programming languages like evolve maintaining
backward compatibility. Most new features take syntactically incorrect
programs and adds syntax and semantics to them.

=== Example of the principle working ===

A good example of when this principle works is meta text. We said that
a meta text looks like this (with Vim regexps):

    ^&lt;&lt;&lt;[^ \t]\+\([ \t\n]\_.\{-}\)\=&gt;&gt;&gt;$

In more detail:

    ^                    - beginning of line
    &lt;&lt;&lt;                  - &lt;&lt;&lt;
    [^ \t]\+             - head (command or type of meta text)
    \([ \t\n]\_.\{-}\)\= - the body of the meta text, preceded by a
                           whitespace that separates it from the head
    &gt;&gt;&gt;                  - &gt;&gt;&gt;
    $                    - end of line

(I later realized this regexp-stuff is totally unnecessary here, but I
don't have the heart to delete it.)

Currently this would be an incorrect post:

    &lt;&lt;&lt;xx something&gt;&gt;&gt;

But at some point we may decide to use "xx" as a meta text type, and
with that decision, this post would be turned into a correct one.

Another example is the &lt;&lt;&lt;wiki&gt;&gt;&gt; text. Until we say what does it
exactly mean, anyone who uses it risks being incompatible with a
future version of post syntax. But once we said that, we kinda promise
that if you use it, the syntax of your post will be correct forever.

Of course while there are just the two and a half of us, we can cheat.
By cheating I mean being not backward compatible and modify old posts
to conform the new syntax. But I think it is a good practice to cheat
as little as possible. I would like to make the foundation of the
syntax/semantics so robust, that we won't ever have to cheat. If we
don't cheat now, we can be safe that we won't have to cheat later.

=== Example of the principle not working ===

I'll give an example that does not respect the principle.

Consider we convert [<a href="http://link">http://link</a> text] (\[<a href="http://.\{-}\]">http://.\{-}\]</a>) into an
HTML link, but we accept anything else as normal text. We release a
version of Hk that works this way. Then we realize sometimes we want
to write lines like this:

    My favourite author is [<a href="http://en.wikipedia.org/wiki/Isaac_Asimov">http://en.wikipedia.org/wiki/Isaac_Asimov</a>
    Isaac Asimov, the genius.]

But we can't go back without cheating, because we said this was a
syntactically/semantically correct text already!

We have to put a lot of effort now into avoiding these kind of
problems in the future.

=== Example: your concrete proposal ===

Further thought experiments on the subject.

A proposal to your link-in-the-text problem (the idea is borrowed from
Sphinx):

    Please have a look at [this site _1].

    &lt;&lt;&lt;link _1 <a href="http://www.example.com>>>">http://www.example.com&gt;&gt;&gt;</a>.

Theoretically, we would not break the principle, because "&lt;&lt;&lt;link"
would have made the post incorrect, which would be turned into correct
by the proposal. It is not very nice though that parsing the footnote
heads is affected by the kinds of meta text that are present in the
post.

== My proposal ==

I love the way we think about the syntax of meta text. I think maybe
that is what we need now, but in more general. This may sound a bit
strong, but here it is.

Let's handle [...] special _all the time_ when it is outside a raw
text. (The line is a raw text if its first character is a whitespace.
Except when it is in an itemization; now don't think about this, I'll
elaborate on this later in this post.) We could throw &lt;&lt;&lt; and &gt;&gt;&gt;
away. I'll call these [...] syntax elements "bracket segments".

If you are worried about how many times we use '[' and ']', I have
looked at our posts. (You are free to ignore my regexps again :) )

- We have 54510 lines that are not quotes (grep -v '^&gt;' *.post).
- 1419 of these lines contain '[' (... | grep -e '\[').
- 436 of the 1419 started with whitespace.
- 690 of the remaining lines contained '^[^\]\[]*\[\d\][^][]*$',
  i.e. they contained a "[, digit, ]" sequence and no brackets
  anywhere else in the line. These were the lines that contained one
  footnote header or footnote body. (Or contained code like a[0], but
  that would be a problem with the current footnote-plan, as well.)
- 29 of the remaining lines contained '^[^\]\[]*\(\[\d\+\][^][]*\)*$'.
  These were the lines with multiple digits and/or multiple citations,
  but no other '[' and ']'.
- in 126 of the remaining lines we talked about tags (e.g. "I like the
  [hh] tag"). We could use quotation signs in these cases.
- 50 of the remaining lines should have been start with whitespace.
- 88 lines remained. This is a tiny number compared the number of
  total lines. So if we go with []-s as meta text and everything, 22
  post in average would contain one '[' that should be escaped.

Back to the proposal:
- I propose escaping a '[' by writing '\['. ']' can live without
  escaping. We also may have `` for inline raw text, in which [ would
  not be interpreted.
- We could retain the meta text model: the first word should indicate
  the type of the meta text. This word could be any symbol-sequence,
  actually, that excludes whitespace.

Examples follow.

=== Meta text and command ===

   [note I am drunk.]

   [todo Something should be done.]

   [!deltext This is boring.]

=== Link ===

    My favourite author is [<a href="http://www.asimovs.com/">http://www.asimovs.com/</a> Isaac Asimov]

    My favourite author is [<a href="http://en.wikipedia.org/wiki/Isaac_Asimov">http://en.wikipedia.org/wiki/Isaac_Asimov</a>
    Isaac Asimov].

    Have a look at [<a href="http://www.asimovs.com/]!">http://www.asimovs.com/]!</a>

=== Footnote ===

    My favourite author is Isaac Asimov [1].

    [1] <a href="http://en.wikipedia.org/wiki/Isaac_Asimov">http://en.wikipedia.org/wiki/Isaac_Asimov</a>

Another one:

    My favourite author is [1 Isaac Asimov].

    [1] <a href="http://en.wikipedia.org/wiki/Isaac_Asimov">http://en.wikipedia.org/wiki/Isaac_Asimov</a>

Latter is equivalent to this (and will be transformed to this before
processing):

    My favourite author is [1 Isaac Asimov].

    [1 <a href="http://en.wikipedia.org/wiki/Isaac_Asimov]">http://en.wikipedia.org/wiki/Isaac_Asimov]</a>

=== Escaping ===

    In Python, "x\[0] = 0" is invalid if x is a tuple.

=== Inline raw text ===

    In Python, [raw] x[0] = 0 [/raw] is invalid if x is a tuple.

`` is of course better to read:

    In Python, `x[0] = 0` is invalid if x is a tuple.

My point is, we have to decide on using `` now (otherwise we will
break compatibility), but we would be free to introduce [raw] at any
time in the future.

=== Summary ===

Types of bracket segments:
- first word matches \w\+ -&gt; meta text (e.g. "[note ...]")
- first word matches /\w\+ -&gt; meta text (e.g. "[/raw])
- first word matches !\w\+ -&gt; command (e.g. "[!deltext ...]")
- first word matches \w\+://.* -&gt; link
- first word matches \d\+ in the beginning of the line -&gt; footnote body
- first word matches \d\+ -&gt; footnote head

== Cites ==

<span class="quote"><span class="quote-2">&gt;&gt; I would also like to write emails like this:
&gt;&gt;
&gt;&gt;   Our website [1] should be improved according to them [2].
&gt;&gt;
&gt;&gt;   [1] Currently </span></span><span class="quote"><span class="quote-2"><a href="http://hste.uw.hu/heapkeeper/index.html">http://hste.uw.hu/heapkeeper/index.html</a></span></span><span class="quote"><span class="quote-2">
&gt;&gt;   [2] </span></span><span class="quote"><span class="quote-2"><a href="http://www.boring.org">http://www.boring.org</a></span></span><span class="quote"><span class="quote-2">, section "Heapkeeper is boring"
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Now, if I understand you correctly, you would also like to handle
&gt; those cites that fall into neither of these, namely, the ones which
&gt; contain both an URL and a textual comment. The question is, of course,
&gt; how should we handle these? Would the head link to the body, or right
&gt; to the URL contained in the body (assuming, of course, that there's
&gt; only one URI in the body!)

</span></span>I think linking to the first URL is a good solution.

There are two possibilities to solve the "two links for one footnote"
problem that you describe:

a. The text of the footnote points somewhere and there is an image
   next to it that points somewhere else.
b. The tooltip of the link shows the text of the footnote body.

I prefer the second one, but YMMV.

== Quotes ==

<span class="quote"><span class="quote-2">&gt;&gt; Are you sure this recursive structure is the best one?
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; No, not at all. We should have a discussion dedicated solely to this
&gt; matter, maybe on Skype or IRC?

</span></span>OK.

<span class="quote"><span class="quote-2">&gt;&gt; I think from the parser's point of view the two approaches need equal
&gt;&gt; amount of work. From the HTML presentation's point of view, yours is
&gt;&gt; probably easier. From the point of view of all the other processors,
&gt;&gt; though, I think my approach is simpler.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; This point also needs to be clarified, and I'm really eager to hear
&gt; about your ideas. This, I think, is one of the most difficult matters
&gt; in body parsing.

</span></span>The HTML probably will have the same recursive structure as the quotes
in the segment list in your proposal. That's why I think it is easier
to write the HTML generator if it can be recursive. (Although I don't
want to see recursive functions in Hk if I don't have a guarantee
about the length of the recursion.)

All the other body processors that want to do something with quotes
will be more complicated if they have to walk through the recursive
structure of quote segments. Otherwise they can just do a loop on all
segments.

Do you need further clarification?

== Authors and signatures ==

<span class="quote"><span class="quote-1">&gt; I've been omitting the signature from my posts from some time now.

</span></span>For 3 weeks apparently. I haven't noticed, just now that you pointed
out.

<span class="quote"><span class="quote-1">&gt; We don't have to sign our mails since the body parser can put the
&gt; signature there automatically when displaying the post. But to avoid
&gt; having two signatures, we should ignore the signatures already
&gt; present. An equivalently viable approach would be to output the
&gt; generated signature only if there is the body itself does not
&gt; contain a signature.

</span></span>Why should we generate signature?

I think if we want to see signatures in post pages (e.g. because
that's how people usually write emails), we want to see signatures in
emails. If we don't want to see signatures in emails, we do we want to
see them in post pages?

Maybe we should not sign our emails at all and should not generate
signatures in posts.

=== Itemization ===

<span class="quote"><span class="quote-2">&gt;&gt; And here is another one. I write itemizations very frequently. Like
&gt;&gt; these:
&gt;&gt;
&gt;&gt;    Nice animals:
&gt;&gt;    - cat
&gt;&gt;    - dog
&gt;&gt;    - fish
&gt;&gt;
&gt;&gt;    We could do:
&gt;&gt;    a. this
&gt;&gt;    b. that
&gt;&gt;
&gt;&gt;    If we choose (a), we have to:
&gt;&gt;    1. start
&gt;&gt;    2. stop
&gt;&gt;
&gt;&gt; We have to find a way to render these. (I haven't found yet.)
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; This is another important issue. I've also thought about them. I this
&gt; topic would also have to be included into our consultation.

</span></span>My proposal gives a straightforward way to solve this problem.
"[-]" would mean: "itemize the following paragraph". Examples:

    Nice animals:[-]
    - cat
    - dog
    - fish

    We could do:[-]
    a. this
    b. that

    If we choose (a), we have to:[-]
    1. start
    2. stop

Actually, [-] would be more special than other bracket segments,
because it would stop the lines starting with whitespace from becoming
raw text:

    My favourite book writers:[-]
    - Isaac Asimov: he was born in the Soviet Union, but his family
      emigrated to the US when he was 3.
    - Richard Dawkins: he was born in Kenya as a son of British
      parents. They returned to England when he was 8.

Which means that Dissector has to know about "[-]".

If we want to put blank lines between the items, I suggest using
another bracket segment indicator for that. Something like this:

    My favourite book writers: [items]

    - Isaac Asimov: he was born in the Soviet Union, but his family
      emigrated to the US when he was 3.

    - Richard Dawkins: he was born in Kenya as a child of British
      parents. They returned to England when he was 8.

    [/items]

Combining items and raw lines is easy: items end with a blank line.

    Hello world in different languages: [items]

    - C++: a very complicated language, developed by Bjarne
      Stroustrup at Bell Labs.

      #include &lt;iostream&gt;

      int main()
      {
          std::cout&lt;&lt;"Hello world!"&lt;&lt;std::endl;
      }

    - Python: a beautiful language, developed by Guido van Rossum.

      import sys;

      sys.stdout.write('Hello world!\n')

    [/items]

== Quotes again ==

I realized we do want to handle quotes as just "quote blocks". For
example they can have raw text inside them. They also may have
itemizations inside them. They may contain links.

I propose that we parse everything in quotes. (I suggested the exact
opposite so far, but I think I was wrong. The concrete examples we had
(meta text, cites) would not make too much sense to parse in quotes;
but in general, there is a point in parsing them, and as we talk now,
new and new text objects come up that must be parsed inside quotes.)

== Raw text ==

Beware the blank lines:

    Code:

        print 1

        print 2

    Isn't it nice?

Although the line between "print 1" and "print 2" is totally empty, it
should be part of the raw text, i.e. as if it started with whitespace.
But we should not handle the blank line after "print 2" as raw text...

== Modularity, parser steps (was: Wiki-like headers) ==

<span class="quote"><span class="quote-3">&gt;&gt;&gt; Plaintext:
&gt;&gt;&gt;
&gt;&gt;&gt;    &lt;&lt;&lt;wiki&gt;&gt;&gt;
&gt;&gt;&gt;    == Bacteria ==
&gt;&gt;&gt;
&gt;&gt;&gt; Initial segmenting:
&gt;&gt;&gt;
&gt;&gt;&gt;    Plaintext [&lt;&lt;&lt;wiki&gt;&gt;&gt;\n== Bacteria ==]
</span></span><span class="quote"><span class="quote-2">&gt;&gt; I don't know how do you think the parser will work, but I would think
&gt;&gt; it never creates that text. It is highly illogical to me that our main
&gt;&gt; text object is the TeX-like paragraph, and everything else is parsed
&gt;&gt; from those. Consider this:
&gt;&gt;
&gt;&gt;    &lt;&lt;&lt;note
&gt;&gt;
&gt;&gt;    This is a long note.
&gt;&gt;
&gt;&gt;    Eh.&gt;&gt;&gt;
&gt;&gt;
&gt;&gt; In my opinion we can create the following text objects in first go:
&gt;&gt; - quote blocks
&gt;&gt; - meta text blocks
&gt;&gt; - text blocks
&gt;&gt; - raw blocks (lines that start with whitespace and would be in a text
&gt;&gt;  block otherwise)
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; In general, I like the idea, but it seems to conflict with the idea of
&gt; modularity. If we hardwire these in the Dissector (in the current
&gt; implementation, this is the name of the module that creates the
&gt; initial segmentation), the module to process, say, quotes will not be
&gt; turned off by simply not loading its module into the parser framework.
&gt; Adding a new kind of object will not be impossible, though, only we
&gt; have to find them in the initial segments. Maybe the Dissector could
&gt; be customized: by default, it'd create all the text object you've
&gt; mentioned, but they could be turned off individually.

</span></span>We don't have to be _that_ modular. If Dissector creates these blocks,
we can say Dissector is one module. It should not be more then one
screen of "real" code -- why should we modularize that?

<span class="quote"><span class="quote-2">&gt;&gt; The first go takes into account only the first few characters of each
&gt;&gt; line.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Yes, this would be very important. Right now, parsing only the headers
&gt; is quite a task, with only ~2000 posts. Imagine what happens if the
&gt; whole body will be parsed!

</span></span>Well, my latest proposal is a bit different from what I said here...
But I don't think that makes a difference in efficiency.

These I the steps I propose now:

First go:
- quote segments
- non-quote segments

Second go (in both previous segments):
- text segments
- bracket segments
- raw segments
- itemizations item segments, see later

Third go:
- text segments -&gt; text paragraphs, separators

A possible layout:

    &gt; Eh.
    &gt;
    &gt; Watch [<a href="http://this">http://this</a> this]!
    &gt;
    &gt; Code:
    &gt;   print "hello"
    &gt;
    &gt; Items:[-]
    &gt; - item 1
    &gt; - item 2

    Yes.

    Watch [<a href="http://that">http://that</a> that].

    In my opinion:
      print "hi"

    My items:[-]
    a. item 1
    b. item 2

The structure after each steps (I don't care about newlines here,
the real implementation will probably contain some):

    quote level  type      text
    ------------------------------------------
    1            text       'Eh.'
    1            separator
    1            text       'Watch'
    1            bracket    '<a href="http://this">http://this</a> this'
    1            text       '!'
    1            separator
    1            text       'Code:'
    1            raw        ' print "hello"'
    1            separator
    1            text       'Items:'
    1            bracket    '-'
    1            item       '- item 1'
    1            item       '- item 2'
    0            text       'Yes.'
    0            separator
    0            text       'Watch '
    0            bracket    '<a href="http://that">http://that</a> that'
    0            text       '.'
    0            separator
    0            text       'In my opinion:'
    0            raw        '  print "hi"'
    0            separator
    0            text       'My items:'
    0            bracket    '-'
    0            item       'a. item 1'
    0            item       'b. item 2'

Each line of this table could be an object of a Segment class. This
class could have an integer `quote_level` data attribute, an enum
`type` attribute and a string `text` attribute. (There is no enum type
in Python, but we can use integer constants instead.) Segments may
have additional attributes later.

== Posts we have ==

We do have a lot of meta text now. If/when we all agreed that the
body parsing should be done according to my proposal and implemented it
that way, I suggest replacing all '^&lt;&lt;&lt;' with '[' and all '.&gt;&gt;&gt;$' with
']' in the posts.

== Conclusion ==

The more I think about it, the more I like my proposal... Please give
it serious consideration.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/325 -->
<span class="postsummary" id="post_hh/325">
<span class="author">Csaba Hoch</span>
<span class="subject">Footnotes in cites</span>
<span class="index"><a href="../hh/thread_156.html#post_hh/325">&lt;hh/325&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/308">&lt;&uarr;hh/308&gt;</a></span>
<span class="date">(2009-05-24)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; I realized we do want to handle quotes as just "quote blocks". For
&gt; example they can have raw text inside them. They also may have
&gt; itemizations inside them. They may contain links.
&gt;
&gt; I propose that we parse everything in quotes. (I suggested the exact
&gt; opposite so far, but I think I was wrong. The concrete examples we
&gt; had (meta text, cites) would not make too much sense to parse in
&gt; quotes; but in general, there is a point in parsing them, and as we
&gt; talk now, new and new text objects come up that must be parsed
&gt; inside quotes.)

</span></span>Now I realized another thing: parsing and processing the footnotes in
quotes are two different things. If I look at this way, it is obvious
how we should handle footnote-heads in quotes:
1. We should definitely parse them.
2. They should point to the place where they should point.

The latter sentence seems silly, and still, it catches nicely what I
want to say.

Example:

First email:

    Nice place: [1]

    [1] <a href="http://nice.place">http://nice.place</a>

Answer:

    &gt; Nice place: [1]

    Indeed!

How should we display "[1]" be on the post page of the second post?
Of course it should be a link to <a href="http://nice.place!">http://nice.place!</a>
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/376 -->
<span class="postsummary" id="post_hh/376">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/376">&lt;hh/376&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/325">&lt;&uarr;hh/325&gt;</a></span>
<span class="date">(2009-06-04)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; Now I realized another thing: parsing and processing the footnotes in
&gt; quotes are two different things. If I look at this way, it is obvious
&gt; how we should handle footnote-heads in quotes:
&gt; 1. We should definitely parse them.
&gt; 2. They should point to the place where they should point.

</span></span>I've read this sentence a few times, but it still makes no sense, only
with the example.

<span class="quote"><span class="quote-1">&gt; Example:
&gt;
&gt; First email:
&gt;
&gt;    Nice place: [1]
&gt;
&gt;    [1] </span></span><span class="quote"><span class="quote-1"><a href="http://nice.place">http://nice.place</a></span></span><span class="quote"><span class="quote-1">
&gt;
&gt; Answer:
&gt;
&gt;    &gt; Nice place: [1]
&gt;
&gt;    Indeed!
&gt;
&gt; How should we display "[1]" be on the post page of the second post?
&gt; Of course it should be a link to </span></span><span class="quote"><span class="quote-1"><a href="http://nice.place!">http://nice.place!</a></span></span><span class="quote"><span class="quote-1">

</span></span>A possible solution, but not the only one. It is a viable option if
the footnote body contains nothing but an URL. If there's anything
else included, it would also have to be displayed.

I imagine the output for every post that includes footnotes would have
a "footnote body block". This would be based on the footnote bodies of
the post in question, but also the parents, where needed by quoted
footnotes. To clarify with an example:

First post:

    Nice place: [1]

    [1] <a href="http://nice.place">http://nice.place</a>

Second post

    &gt; Nice place: [1]

    Indeed!

Sample output for the second post:

    &gt; Nice place: [&gt;1]

    Indeed!

    ----

    [&gt;1] <a href="http://nice.place">http://nice.place</a>

Hk could automatically display a [1] as [&gt;1] when quoted 1-deep, to
help avoid confusion with [1], which would be used in the unquoted
part of the post.
</pre></div>
</span><!-- postsummary -->
</div><!-- postbox for post hh/376 -->
</div><!-- postbox for post hh/325 -->

<div class="postbox"><!-- post hh/330 -->
<span class="postsummary" id="post_hh/330">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/330">&lt;hh/330&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/308">&lt;&uarr;hh/308&gt;</a></span>
<span class="date">(2009-05-24)</span>
<div class="body">
<pre class="postbody">== Basic principle of post syntax and semantics ==

=== Example of the principle working ===

<span class="quote"><span class="quote-1">&gt; Of course while there are just the two and a half of us, we can cheat.
&gt; By cheating I mean being not backward compatible and modify old posts
&gt; to conform the new syntax. But I think it is a good practice to cheat
&gt; as little as possible. I would like to make the foundation of the
&gt; syntax/semantics so robust, that we won't ever have to cheat. If we
&gt; don't cheat now, we can be safe that we won't have to cheat later.

</span></span>I mostly agree, but I would like to remind you that this time while there
are so few of us is precious in that we can still drastically change the
syntax, so that maintaining backwards compatibility won't but that much
of a burden on us in case of old and truly outdated syntax.

In other words: our syntax is not yet frozen, and we should make use
of this fact.

=== Example of the principle not working ===

<span class="quote"><span class="quote-1">&gt; But we can't go back without cheating, because we said this was a
&gt; syntactically/semantically correct text already!
&gt;
&gt; We have to put a lot of effort now into avoiding these kind of
&gt; problems in the future.

</span></span>Simply put: we can only expand the syntax, never shrink or alter.
This means that the space of "incorrect" posts is very valuable to us,
since it is this space that we can use to introduce new syntax. But,
we must take great care not to run out of this precious resource, or
we strip ourself of the possibility to introduce new elements.

This brings up an exercise of maintaining delicate balance. So, if you
introduce a new syntactic element, it has to make a sufficiently large
set of invalid posts valid, but not too much, to keep the way open for
retreat if the idea turns out to be a mistake.

== My proposal ==

<span class="quote"><span class="quote-1">&gt; - 690 of the remaining lines contained '^[^\]\[]*\[\d\][^][]*$',

</span></span>&lt;&lt;&lt;!todo Correct and remove this.&gt;&gt;&gt;

In this regexp, you use two different sequences to denote the same
pattern:

    ^ - start of line
    [^\]\[] - anything but '[' or ']'
    * - 0 or more of these
    \[ - a '['
    \d - a digit
    \] - a ']'
    [^][] - anything but '[' or ']'
    *
    $ - end of line


Since '[^][]' is easier to read, I think we should use that.

<span class="quote"><span class="quote-1">&gt; - 50 of the remaining lines should have been start with whitespace.

</span></span>&lt;&lt;&lt;!todo should have been started&gt;&gt;&gt;

Your results are interesting!

<span class="quote"><span class="quote-1">&gt; - I propose escaping a '[' by writing '\['. ']' can live without

</span></span>&lt;&lt;&lt;!todo Rather "do without"&gt;&gt;&gt;

A remark: we should pay attention to eliminating the "multiple quote
heads" we used earlier; these look like \[3,4].

== Cites ==

<span class="meta-text">[!todo We should change "cite" to "footnote".]</span>

<span class="quote"><span class="quote-1">&gt; There are two possibilities to solve the "two links for one footnote"
&gt; problem that you describe:
&gt;
&gt; a. The text of the footnote points somewhere and there is an image
&gt;   next to it that points somewhere else.
&gt; b. The tooltip of the link shows the text of the footnote body.
&gt;
&gt; I prefer the second one, but YMMV.

</span></span>The second one is a great idea!

== Quotes ==

<span class="quote"><span class="quote-1">&gt; The HTML probably will have the same recursive structure as the quotes
&gt; in the segment list in your proposal. That's why I think it is easier
&gt; to write the HTML generator if it can be recursive. (Although I don't
&gt; want to see recursive functions in Hk if I don't have a guarantee
&gt; about the length of the recursion.)

</span></span>Here, you have a guarantee that the depth of the recursion will not
exceed the depth of the quotation, which I'd like not to exceed 20 in
any reasonable conversation.

<span class="quote"><span class="quote-1">&gt; All the other body processors that want to do something with quotes
&gt; will be more complicated if they have to walk through the recursive
&gt; structure of quote segments. Otherwise they can just do a loop on
&gt; all segments.

</span></span>Just as long as we don't want to do any complicated processing inside
the quotes. For example, if we want to interpret footnote headers
inside cites, that would be easier if the representation were
hierarchical.

But since we probably don't want to do this, I'm being swayed towards
flat representation. Simple representation is probably better than
simple algorithm, at least that's what Heapkeeper's evolution has been
about so far.

== Authors and signatures ==

<span class="quote"><span class="quote-1">&gt; Why should we generate signature?

</span></span>Ummm...

<span class="quote"><span class="quote-1">&gt; Maybe we should not sign our emails at all and should not generate
&gt; signatures in posts.

</span></span>But since it wouldn't be hard, why not make it possible? Of course,
not as a first priority.

=== Itemization ===

<span class="meta-text">[!todo Should be second-level header.]</span>

I like your solution. It really is elegant, although at first I wanted
to argue against it, since it is somewhat arteficial, ie. the post
author must pay attention.

An addition: itemizations look neat with the non-first lines of an
item being indented by 2. Emacs or Vim can create these automatically,
but we should nonetheless recognize multiline items even if the
non-first lines are not indented, as it would make the life of those
using more simplistic editors unconfortable.

So I think this would also have to be valid:

   My favourite book writers:[-]
   - Isaac Asimov: he was born in the Soviet Union, but his family
   emigrated to the US when he was 3.
   - Richard Dawkins: he was born in Kenya as a son of British
   parents. They returned to England when he was 8.

== Raw text ==

<span class="quote"><span class="quote-1">&gt;        print 2
&gt;
&gt;    Isn't it nice?
&gt;
&gt; Although the line between "print 1" and "print 2" is totally empty, it
&gt; should be part of the raw text, i.e. as if it started with whitespace.

</span></span>Yes.

<span class="quote"><span class="quote-1">&gt; But we should not handle the blank line after "print 2" as raw text...

</span></span>== Quotes again ==

<span class="quote"><span class="quote-1">&gt; I realized we do want to handle quotes as just "quote blocks". For
&gt; example they can have raw text inside them. They also may have
&gt; itemizations inside them. They may contain links.

</span></span><span class="meta-text">[!todo I realized we do not want to...]</span>

<span class="quote"><span class="quote-1">&gt; I propose that we parse everything in quotes. (I suggested the exact
&gt; opposite so far, but I think I was wrong. The concrete examples we had
&gt; (meta text, cites) would not make too much sense to parse in quotes;
&gt; but in general, there is a point in parsing them, and as we talk now,
&gt; new and new text objects come up that must be parsed inside quotes.)

</span></span>I am happy you came to this conclusion. But don't you think it
justifies hierarchical storing of quotes? If we parse a quote just
like a body, it should be stored the same way.

== Modularity, parser steps (was: Wiki-like headers) ==

<span class="quote"><span class="quote-2">&gt; &gt; Maybe the Dissector could
&gt; &gt; be customized: by default, it'd create all the text object you've
&gt; &gt; mentioned, but they could be turned off individually.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; We don't have to be _that_ modular. If Dissector creates these blocks,
&gt; we can say Dissector is one module. It should not be more then one
&gt; screen of "real" code -- why should we modularize that?

</span></span>OK by me. But what would we do if the Dissector creates Quote segments,
and the Parser stack contains no module to process them?

<span class="quote"><span class="quote-1">&gt; Well, my latest proposal is a bit different from what I said here...
&gt; But I don't think that makes a difference in efficiency.

</span></span>Of course, efficiency will still remain a top priority, but with the
new proposal, we'll have to pay more attention, as the metas no longer
need be at the start of the line.

<span class="quote"><span class="quote-1">&gt; These I the steps I propose now:

</span></span><span class="meta-text">[!todo These are the steps...]</span>

<span class="quote"><span class="quote-1">&gt; Each line of this table could be an object of a Segment class. This
&gt; class could have an integer `quote_level` data attribute, an enum
&gt; `type` attribute and a string `text` attribute. (There is no enum type
&gt; in Python, but we can use integer constants instead.) Segments may
&gt; have additional attributes later.

</span></span>I like the simplicity of this model.

== Posts we have ==

<span class="quote"><span class="quote-1">&gt; We do have a lot of meta text now. If/when we all agreed that the
&gt; body parsing should be done according to my proposal and implemented it
&gt; that way, I suggest replacing all '^&lt;&lt;&lt;' with '[' and all '.&gt;&gt;&gt;$' with
&gt; ']' in the posts.

</span></span>I think we should do this change only manually. Sounds too drastic to
do in one move.

<span class="meta-text">[!delthis On the UMS heap, my maintaining effort covered no more than
about 150-200 posts, the rest are yet untouched, or, at least, not
marked as reviewed. So, not very much work has to be done twice.]</span>

== Conclusion ==

My conclusion: we made a rational choice when choosing the "&lt;&lt;&lt; &gt;&gt;&gt;"
syntax for metas. It was a careful choice made on no practical
experience. Now we have the experience to make the move to a more
simple solution.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/332 -->
<span class="postsummary" id="post_hh/332">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/332">&lt;hh/332&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/330">&lt;&uarr;hh/330&gt;</a></span>
<span class="date">(2009-05-25)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; &lt;&lt;&lt;!todo Rather "do without"&gt;&gt;&gt;
&gt;
&gt; A remark: we should pay attention to eliminating the "multiple quote
&gt; heads" we used earlier; these look like \[3,4].
&gt;
&gt; == Cites ==
&gt;
&gt; [!todo We should change "cite" to "footnote".]

</span></span>I guess this was the point where you were convinced to use brackets
instead of the old meta syntax :) Seven lines earlier you used the old
meta syntax, here you use a bracket segment.

== Quotes ==

<span class="quote"><span class="quote-2">&gt;&gt; The HTML probably will have the same recursive structure as the quotes
&gt;&gt; in the segment list in your proposal. That's why I think it is easier
&gt;&gt; to write the HTML generator if it can be recursive. (Although I don't
&gt;&gt; want to see recursive functions in Hk if I don't have a guarantee
&gt;&gt; about the length of the recursion.)
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Here, you have a guarantee that the depth of the recursion will not
&gt; exceed the depth of the quotation, which I'd like not to exceed 20 in
&gt; any reasonable conversation.

</span></span>You don't know how long discussions our users will have on their heaps.

<span class="quote"><span class="quote-2">&gt;&gt; All the other body processors that want to do something with quotes
&gt;&gt; will be more complicated if they have to walk through the recursive
&gt;&gt; structure of quote segments. Otherwise they can just do a loop on
&gt;&gt; all segments.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Just as long as we don't want to do any complicated processing inside
&gt; the quotes. For example, if we want to interpret footnote headers
&gt; inside cites, that would be easier if the representation were
&gt; hierarchical.

</span></span>No, it would not be!

An example:

    &gt;&gt; Watch this: [1]

    &gt; Or this: [1]

    No, this: [1]

    [1] <a href="http://no.this">http://no.this</a>

(Note: this email does not contain footnote-bodies for the
footnote-heads in quotes.)

The parsed version of this post would be the following according to my
suggestion about non-hierarchical quote representation:

    quote level  type     text
    ------------------------------------------
    2            text     'Watch this:'
    2            bracket  '1'
    1            text     'Or this:'
    1            bracket  '1'
    0            text     'No, this:'
    0            bracket  '1'
    ...

After the footnote-processor (which may or may not be a different go):

    quote level  type            text
    ------------------------------------------
    2            text           'Watch this:'
    2            footnote-head  '1'
    1            text           'Or this:'
    1            footnote-head  '1'
    0            text           'No, this:'
    0            footnote-head  '1'
    ...

A function that creates HTML from given footnote head of given post:
(post.ancestor(n) returns the nth ancestor of a post. post.footnotes()
returns the dictionary of footnotes, where indices are the keys and
footnote bodies are the values.)

    def footnote_head_to_html(post, footnote_head):
        # post0: the post which defines the footnote
        post0 = post.ancestor(footnote_head.quote_level)
        footnote_body = post0.footnotes()[int(footnote_head.text)]
        ... creating HTML from footnote_body...

How much simpler can it get? It would be more difficult if we used
hierarchical quotes.

<span class="quote"><span class="quote-1">&gt; But since we probably don't want to do this,

</span></span>I do :)

<span class="quote"><span class="quote-1">&gt; I'm being swayed towards flat representation. Simple representation
&gt; is probably better than simple algorithm, at least that's what
&gt; Heapkeeper's evolution has been about so far.

</span></span>True, that could be one of our design principle. In this particular
case, however, simple representation means simple algorithm.

== Authors and signatures ==

<span class="quote"><span class="quote-2">&gt;&gt; Why should we generate signature?
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Ummm...
&gt;
</span></span><span class="quote"><span class="quote-2">&gt;&gt; Maybe we should not sign our emails at all and should not generate
&gt;&gt; signatures in posts.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; But since it wouldn't be hard, why not make it possible?

</span></span>Because it is not useful? :D

Joke aside, if you would like to see this feature, go for it, as I
said previously.

== Itemization ==

<span class="quote"><span class="quote-1">&gt; I like your solution. It really is elegant, although at first I wanted
&gt; to argue against it, since it is somewhat arteficial, ie. the post
&gt; author must pay attention.
&gt;
&gt; An addition: itemizations look neat with the non-first lines of an
&gt; item being indented by 2. Emacs or Vim can create these automatically,
&gt; but we should nonetheless recognize multiline items even if the
&gt; non-first lines are not indented, as it would make the life of those
&gt; using more simplistic editors unconfortable.
&gt;
&gt; So I think this would also have to be valid:
&gt;
&gt;    My favourite book writers:[-]
&gt;    - Isaac Asimov: he was born in the Soviet Union, but his family
&gt;    emigrated to the US when he was 3.
&gt;    - Richard Dawkins: he was born in Kenya as a son of British
&gt;    parents. They returned to England when he was 8.

</span></span>OK.

== Quotes again ==

<span class="quote"><span class="quote-2">&gt;&gt; I propose that we parse everything in quotes. (I suggested the exact
&gt;&gt; opposite so far, but I think I was wrong. The concrete examples we had
&gt;&gt; (meta text, cites) would not make too much sense to parse in quotes;
&gt;&gt; but in general, there is a point in parsing them, and as we talk now,
&gt;&gt; new and new text objects come up that must be parsed inside quotes.)
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; I am happy you came to this conclusion. But don't you think it
&gt; justifies hierarchical storing of quotes? If we parse a quote just
&gt; like a body, it should be stored the same way.

</span></span>It _is_ stored in the same way in my proposal. See above.

(I have a feeling that you argued in your mail for hierarchical
storing of quotes _before_ you actually read the end of my email where
I explain how would I actually store quotes.)

== Modularity, parser steps (was: Wiki-like headers) ==

<span class="quote"><span class="quote-3">&gt;&gt;&gt; Maybe the Dissector could be customized: by default, it'd create
&gt;&gt;&gt; all the text object you've mentioned, but they could be turned off
&gt;&gt;&gt; individually.
</span></span><span class="quote"><span class="quote-2">&gt;&gt;
&gt;&gt; We don't have to be _that_ modular. If Dissector creates these blocks,
&gt;&gt; we can say Dissector is one module. It should not be more then one
&gt;&gt; screen of "real" code -- why should we modularize that?
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; OK by me. But what would we do if the Dissector creates Quote segments,
&gt; and the Parser stack contains no module to process them?

</span></span>*Sigh*. There are no "quote segments". See again above and in my
proposal on what segments do I envision.

== Posts we have ==

<span class="quote"><span class="quote-2">&gt;&gt; We do have a lot of meta text now. If/when we all agreed that the
&gt;&gt; body parsing should be done according to my proposal and implemented it
&gt;&gt; that way, I suggest replacing all '^&lt;&lt;&lt;' with '[' and all '.&gt;&gt;&gt;$' with
&gt;&gt; ']' in the posts.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; I think we should do this change only manually. Sounds too drastic to
&gt; do in one move.

</span></span>OK: UMS yours, Hh mine :)

Just kidding. We will see if we want to have some automatism when we
have done a few posts by hand.

== Conclusion ==

<span class="quote"><span class="quote-1">&gt; My conclusion: we made a rational choice when choosing the "&lt;&lt;&lt; &gt;&gt;&gt;"
&gt; syntax for metas. It was a careful choice made on no practical
&gt; experience. Now we have the experience to make the move to a more
&gt; simple solution.

</span></span>Well said!
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/335 -->
<span class="postsummary" id="post_hh/335">
<span class="author">Csaba Hoch</span>
<span class="subject">Itemization</span>
<span class="index"><a href="../hh/thread_156.html#post_hh/335">&lt;hh/335&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/332">&lt;&uarr;hh/332&gt;</a></span>
<span class="date">(2009-05-27)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-2">&gt;&gt; I like your solution. It really is elegant, although at first I wanted
&gt;&gt; to argue against it, since it is somewhat arteficial, ie. the post
&gt;&gt; author must pay attention.
&gt;&gt;
&gt;&gt; An addition: itemizations look neat with the non-first lines of an
&gt;&gt; item being indented by 2. Emacs or Vim can create these automatically,
&gt;&gt; but we should nonetheless recognize multiline items even if the
&gt;&gt; non-first lines are not indented, as it would make the life of those
&gt;&gt; using more simplistic editors unconfortable.
&gt;&gt;
&gt;&gt; So I think this would also have to be valid:
&gt;&gt;
&gt;&gt;    My favourite book writers:[-]
&gt;&gt;    - Isaac Asimov: he was born in the Soviet Union, but his family
&gt;&gt;    emigrated to the US when he was 3.
&gt;&gt;    - Richard Dawkins: he was born in Kenya as a son of British
&gt;&gt;    parents. They returned to England when he was 8.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; OK.

</span></span>I gave more thought to this. The rules of itemization won't be
trivial.

Have a look at these examples (I don't say we have to handle all as
correct itemization):

    Items:[-]
    a bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla
    b bla bla bla
    c bla bla bla bla bla bla bla bla bla bla bla bla bla bla there is
    a person outside

    Items:[-]
    + bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla
    - bla bla bla
    * bla bla bla

    Items:[-]
    - bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla
    - bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla
    a. bla bla bla
    b. bla bla bla

    Items:[-]
    -&gt; bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla
    -&gt; bla bla bla

    Items:[-]
    good: Linux
    bad: Windows
    ugly: guess...

Would we allow only a well-defined set of itemization marks, or do we
want to have a general rule?

These general rules were in my mind that could determine the type of a
line:[-]
1. If a line is empty (or contains only whitespace), the itemization
   is finised.
2. Otherwise, if the line starts with a whitespace, its first word
   (`[^ \t]\+`) is the itemization mark, the rest is text.
3. Otherwise it is text that in the continuation of the previous line.

If you want to accept the example you said you wanted to accept (which
makes sense, I have to admit), then we have to find other rules. They
will be either restrictive (e.g. only a set of itemization marks are
allowed), or quite complicated.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/337 -->
<span class="postsummary" id="post_hh/337">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/337">&lt;hh/337&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/335">&lt;&uarr;hh/335&gt;</a></span>
<span class="date">(2009-05-29)</span>
<div class="body">
<pre class="postbody">This example:

<span class="quote"><span class="quote-1">&gt;     Items:[-]
&gt;     a bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla
&gt;     b bla bla bla
&gt;     c bla bla bla bla bla bla bla bla bla bla bla bla bla bla there is
&gt;     a person outside

</span></span>is quite probably the one that hurts the most. The short form of the
English indefinite article (which happens to be the same as the short
form of the Hungarian definite article, just for added linguistic joy),
is of course frequent enough to accidentally start a line. But
luckily, both English and Hungarian typographical conventions dictate
this to be written as:

     Items:[-]
     a. bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla
     b. bla bla bla
     c. bla bla bla bla bla bla bla bla bla bla bla bla bla bla there is
     a person outside

If we accept only letters and numbers followed by a period, comma or
closing parentheses as numbering, we can solve this case, as long as
"a" at the end of a grammatic structure is invalid. This is the case
in Hungarian and English, but not in French, where this single letter
word is the present tense singular 3rd person form of the verb "avoir",
"to have". (Still pretty uncommon at the end of a sentence, but not
impossible.)

But what if one needs structures like this:

    Head:[-]
    a. Apple
    aa. Green apple
    ab. Red apple
    b. Banana
    ba. Green banana
    bb. Yellow banana
    bba. Yellow banana with brown spots

Lawyers like to use this kind of multi-level itemization with
multi-character letter marking.

Other than this, I think we can live with a fixed set of itemization
marks. A sensible set would be [-+*]. Do you think we need others?
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/338 -->
<span class="postsummary" id="post_hh/338">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/338">&lt;hh/338&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/337">&lt;&uarr;hh/337&gt;</a></span>
<span class="date">(2009-05-29)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt;      Items:[-]
&gt;      a. bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla
&gt;      b. bla bla bla
&gt;      c. bla bla bla bla bla bla bla bla bla bla bla bla bla bla there is
&gt;      a person outside

</span></span>Just to annoy you:

      Items:[-]
      a. bla
      b. bla bla bla
      c. bla bla bla bla bla bla bla bla bla bla bla bla bla bla there is
      d. bla
      e. I wanted to write a Python function. A good friend of mine told
      me the name of the function should be g, but I think it should be
      f. I think though g is better.

<span class="quote"><span class="quote-1">&gt; But what if one needs structures like this:
&gt;
&gt;     Head:[-]
&gt;     a. Apple
&gt;     aa. Green apple
&gt;     ab. Red apple
&gt;     b. Banana
&gt;     ba. Green banana
&gt;     bb. Yellow banana
&gt;     bba. Yellow banana with brown spots
&gt;
&gt; Lawyers like to use this kind of multi-level itemization with
&gt; multi-character letter marking.

</span></span>Oh, I haven't thought about multiple levels. It would be very
convenient to write stuff like this:

    My favourite things:[-]
    - Authors:
        - Asimov
        - Dawkins
    - Sitcoms:
        - Two and a half men
        - Friends

A possible solution, which I very much dislike:

    My favourite things:[-]
    - Authors:[-]
        - Asimov
        - Dawkins
    - Sitcoms:[-]
        - Two and a half men
        - Friends

I'm confident we can define indentation-based itemizations without
having to write more than one `[-]`.

<span class="quote"><span class="quote-1">&gt; Other than this, I think we can live with a fixed set of itemization
&gt; marks. A sensible set would be [-+*]. Do you think we need others?

</span></span>I would also like to have numbers.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/341 -->
<span class="postsummary" id="post_hh/341">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/341">&lt;hh/341&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/338">&lt;&uarr;hh/338&gt;</a></span>
<span class="date">(2009-05-29)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; Just to annoy you:
&gt;
&gt;       Items:[-]
&gt; ...
&gt;       e. I wanted to write a Python function. A good friend of mine told
&gt;       me the name of the function should be g, but I think it should be
&gt;       f. I think though g is better.

</span></span>Yes. So it's either your solution with the indentation, or once again
we ask the user to be careful, and put things like that within single
or double quotes.

<span class="quote"><span class="quote-2">&gt;&gt; But what if one needs structures like this:
&gt;&gt;
&gt;&gt;     Head:[-]
&gt;&gt;     a. Apple
&gt;&gt;     aa. Green apple
&gt;&gt;     ab. Red apple
&gt;&gt;     b. Banana
&gt;&gt;     ba. Green banana
&gt;&gt;     bb. Yellow banana
&gt;&gt;     bba. Yellow banana with brown spots
&gt;&gt;
&gt;&gt; Lawyers like to use this kind of multi-level itemization with
&gt;&gt; multi-character letter marking.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Oh, I haven't thought about multiple levels. It would be very
&gt; convenient to write stuff like this:
&gt;
&gt;     My favourite things:[-]
&gt;     - Authors:
&gt;         - Asimov
&gt;         - Dawkins
&gt;     - Sitcoms:
&gt;         - Two and a half men
&gt;         - Friends

</span></span>Indentation is one way. Another would be multiple itemization signs,
as MediaWiki uses it, and I think I'd use this one, purely out of
habit.

 My favourite things:[-]
 * entertainment
 ** reading
 ** films
 * programming
 ** C
 ** Python

<span class="quote"><span class="quote-1">&gt; A possible solution, which I very much dislike:
&gt;
&gt;     My favourite things:[-]
&gt;     - Authors:[-]
&gt;         - Asimov
&gt;         - Dawkins
&gt;     - Sitcoms:[-]
&gt;         - Two and a half men
&gt;         - Friends

</span></span>Me too.

<span class="quote"><span class="quote-1">&gt; I'm confident we can define indentation-based itemizations without
&gt; having to write more than one `[-]`.
&gt;
</span></span><span class="quote"><span class="quote-2">&gt;&gt; Other than this, I think we can live with a fixed set of itemization
&gt;&gt; marks. A sensible set would be [-+*]. Do you think we need others?
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; I would also like to have numbers.

</span></span>Good thing you mentioned that. Now ordinary decimal numbers written in
Arabic numerals are easy to filter out, but it's much more than that.
First, you have multiple number systems, and even in purely
Latin-letter cultures, you have Roman numerals, which are not that
easy to filter out.

So, your use of indentation in all lines after the first is becoming
increasingly attractive. But the idea of forcing our customs on our
potential users, however well-founded they are (our customs), is not.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/344 -->
<span class="postsummary" id="post_hh/344">
<span class="author">Csaba Hoch</span>
<span class="subject">Embedded itemization</span>
<span class="index"><a href="../hh/thread_156.html#post_hh/344">&lt;hh/344&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/341">&lt;&uarr;hh/341&gt;</a></span>
<span class="date">(2009-05-29)</span>
<div class="body">
<pre class="postbody">To sum up, we want to support both itemization formats:

    My favourite things:[-]
    - Authors:
        - Asimov
        - Dawkins
    - Sitcoms:
        - Two and a half men
        - Friends

    My favourite things:[-]
    * entertainment
    ** reading
    ** films
    * programming
    ** C
    ** Python

<span class="quote"><span class="quote-2">&gt;&gt; I'm confident we can define indentation-based itemizations without
&gt;&gt; having to write more than one `[-]`.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; [...]
&gt;
&gt; So, your use of indentation in all lines after the first is becoming
&gt; increasingly attractive.

</span></span>If we want to allow your markup, indentation is not enough, of course,
`[-]` have to know about what is `*` and `**`.

I have been thinking about my embedded itemization structure, as well.
We can do it on a purely indentation-based style only if the poster
uses different indentation levels for embedded items and for
continuation of items.

For example we can't handle the following:

    My favourite things:[-]
    - Authors: they are my favourite book writers. Both of them are
      just brilliant.
      - Asimov
      - Dawkins
    - Sitcoms:
      - Two and a half men
      - Friends

The poster should write either this:

    My favourite things:[-]
    - Authors: they are my favourite book writers. Both of them are
        just brilliant.
      - Asimov
      - Dawkins
    - Sitcoms:
      - Two and a half men
      - Friends

Or this:

    My favourite things:[-]
    - Authors: they are my favourite book writers. Both of them are
      just brilliant.
        - Asimov
        - Dawkins
    - Sitcoms:
        - Two and a half men
        - Friends

The problem is that the first one looks the best.

Sphinx (and rst) solves this problem by requiring empty lines before
and after embedded itemizations:

    My favourite things:

    - Authors: they are my favourite book writers. Both of them are
      just brilliant.

      - Asimov
      - Dawkins

    - Sitcoms:

      - Two and a half men
      - Friends

I definitely don't want to do this.

So I guess I have to accept that some character sequences will be
handled as itemization marks (`[-+*]\+\|\d\+\.`) and other will not
be. I don't think we should care about Roman numerals. [1]

<span class="quote"><span class="quote-3">&gt;&gt;&gt; Other than this, I think we can live with a fixed set of itemization
&gt;&gt;&gt; marks. A sensible set would be [-+*]. Do you think we need others?
</span></span><span class="quote"><span class="quote-2">&gt;&gt; I would also like to have numbers.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Good thing you mentioned that. Now ordinary decimal numbers written in
&gt; Arabic numerals are easy to filter out, but it's much more than that.
&gt; First, you have multiple number systems, and even in purely
&gt; Latin-letter cultures, you have Roman numerals, which are not that
&gt; easy to filter out.

</span></span>Considering the problem of embedded itemizations that I described
above, I don't think we can do anything about these now.

[1] See heap://2079
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/355 -->
<span class="postsummary" id="post_hh/355">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/355">&lt;hh/355&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/344">&lt;&uarr;hh/344&gt;</a></span>
<span class="date">(2009-05-31)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; So I guess I have to accept that some character sequences will be
&gt; handled as itemization marks (`[-+*]\+\|\d\+\.`) and other will not
&gt; be. I don't think we should care about Roman numerals. [1]

</span></span>I think this is the rational consensus between trying to provide a
generic support for itemizations and trying to keep it realizable.

<span class="quote"><span class="quote-4">&gt;&gt;&gt;&gt; Other than this, I think we can live with a fixed set of itemization
&gt;&gt;&gt;&gt; marks. A sensible set would be [-+*]. Do you think we need others?
</span></span><span class="quote"><span class="quote-3">&gt;&gt;&gt;
&gt;&gt;&gt; I would also like to have numbers.
</span></span><span class="quote"><span class="quote-2">&gt;&gt;
&gt;&gt; Good thing you mentioned that. Now ordinary decimal numbers written in
&gt;&gt; Arabic numerals are easy to filter out, but it's much more than that.
&gt;&gt; First, you have multiple number systems, and even in purely
&gt;&gt; Latin-letter cultures, you have Roman numerals, which are not that
&gt;&gt; easy to filter out.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Considering the problem of embedded itemizations that I described
&gt; above, I don't think we can do anything about these now.

</span></span>Yes, I also see the problem. But we should keep the option open for
the demanding user. How about a special meta for nonregular
itemization marks? This could be "*", for example.

    Good:[-]
    [* a.] Authors:
    [* aa.] Asimov
    [* ab.] Stapledon
    [* b.] Drinks:
    [* ba.] Coffee
    [* bb.] Tea
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/358 -->
<span class="postsummary" id="post_hh/358">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/358">&lt;hh/358&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/355">&lt;&uarr;hh/355&gt;</a></span>
<span class="date">(2009-05-31)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-2">&gt;&gt; So I guess I have to accept that some character sequences will be
&gt;&gt; handled as itemization marks (`[-+*]\+\|\d\+\.`) and other will not
&gt;&gt; be. I don't think we should care about Roman numerals. [1]
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; I think this is the rational consensus between trying to provide a
&gt; generic support for itemizations and trying to keep it realizable.

</span></span>OK.

<span class="quote"><span class="quote-5">&gt;&gt;&gt;&gt;&gt; Other than this, I think we can live with a fixed set of itemization
&gt;&gt;&gt;&gt;&gt; marks. A sensible set would be [-+*]. Do you think we need others?
</span></span><span class="quote"><span class="quote-4">&gt;&gt;&gt;&gt; I would also like to have numbers.
</span></span><span class="quote"><span class="quote-3">&gt;&gt;&gt; Good thing you mentioned that. Now ordinary decimal numbers written in
&gt;&gt;&gt; Arabic numerals are easy to filter out, but it's much more than that.
&gt;&gt;&gt; First, you have multiple number systems, and even in purely
&gt;&gt;&gt; Latin-letter cultures, you have Roman numerals, which are not that
&gt;&gt;&gt; easy to filter out.
</span></span><span class="quote"><span class="quote-2">&gt;&gt; Considering the problem of embedded itemizations that I described
&gt;&gt; above, I don't think we can do anything about these now.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Yes, I also see the problem. But we should keep the option open for
&gt; the demanding user.

</span></span>If we say "you can implement it, or we may do so if there is a
demand", that's an open option, too :)

<span class="quote"><span class="quote-1">&gt; How about a special meta for nonregular itemization marks? This
&gt; could be "*", for example.
&gt;
&gt;     Good:[-]
&gt;     [* a.] Authors:
&gt;     [* aa.] Asimov
&gt;     [* ab.] Stapledon
&gt;     [* b.] Drinks:
&gt;     [* ba.] Coffee
&gt;     [* bb.] Tea

</span></span>And what HTML would you generate from that?
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/368 -->
<span class="postsummary" id="post_hh/368">
<span class="author">Attila Nagy</span>
<span class="subject">Html output for multilevel itemizations</span>
<span class="index"><a href="../hh/thread_156.html#post_hh/368">&lt;hh/368&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/358">&lt;&uarr;hh/358&gt;</a></span>
<span class="date">(2009-06-01)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-2">&gt;&gt; How about a special meta for nonregular itemization marks? This
&gt;&gt; could be "*", for example.
&gt;&gt;
&gt;&gt;     Good:[-]
&gt;&gt;     [* a.] Authors:
&gt;&gt;     [* aa.] Asimov
&gt;&gt;     [* ab.] Stapledon
&gt;&gt;     [* b.] Drinks:
&gt;&gt;     [* ba.] Coffee
&gt;&gt;     [* bb.] Tea
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; And what HTML would you generate from that?

</span></span>This can be done using nothing but HTML and CSS. See the example in the CSS
standard:

<a href="http://www.w3.org/TR/CSS2/generate.html#scope">http://www.w3.org/TR/CSS2/generate.html#scope</a>

(Now really, if CSS can support such sophisticated expressions, why
isn't simple algebra like "width: 50%-300px;" supported?)
</pre></div>
</span><!-- postsummary -->
</div><!-- postbox for post hh/368 -->
</div><!-- postbox for post hh/358 -->
</div><!-- postbox for post hh/355 -->
</div><!-- postbox for post hh/344 -->

<div class="postbox"><!-- post hh/345 -->
<span class="postsummary" id="post_hh/345">
<span class="author">Csaba Hoch</span>
<span class="subject">What the users need</span>
<span class="tags">[+discussion, -prop]</span>
<span class="index"><a href="../hh/thread_156.html#post_hh/345">&lt;hh/345&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/341">&lt;&uarr;hh/341&gt;</a></span>
<span class="date">(2009-05-29)</span>
<div class="body">
<pre class="postbody"><span class="meta-text">[todo split thread]</span>

I am just composing two posts about how to make it easier for users to
learn the post syntax [1][2]. Here I will talk about what should be
the philosophy behind the post syntax format.

I think we should acknowledge these "observations":[-]
- First law of syntax formats: 80% of the people don't care.
- Second law of syntax formats: 19% of the people don't want to spend
  initially more than 5 minutes learning it.

<span class="quote"><span class="quote-1">&gt; So, your use of indentation in all lines after the first is becoming
&gt; increasingly attractive. But the idea of forcing our customs on our
&gt; potential users, however well-founded they are (our customs), is
&gt; not.

</span></span>We should talk about what we think the users need, especially with
regards to the post syntax. There are two obvious ways we can build
the post syntax and the post parser.

== In a simple and well-defined way ==

If the post syntax is simple, it will be easy to learn. If it is also
well-defined, people will look at a post and see in a moment exactly
what page will be generated from that. Most wiki syntax formats (e.g.
MediaWiki) use this principle. This solution is conservative: if it is
not sure what the user wants, it considers the post incorrect. If
people are not familiar with the format, at first it may seem
restrictive and non-intuitive to them; but after spending a few
minutes reading the post syntax tutorial page (which should be short),
it will be trivial. Hk's source code (&amp; test &amp; documentation) will be
nice, clean, easy to modify and understand.

As time goes, of course, new features may be introduced with care.

== In a heuristic way ==

Another way is to build a heuristic parser. It will try to understand
what the user wants. Its code and documentation is huge. It does not
have a comprehensive philosophy and it is hard to understand. It is
hard to maintain, especially with regards to backward compatibility.
The programmers who use it will hate it -- how many programmers
actually like using word processors? [3] Maybe it is better for people
who don't care and don't know what they are doing anyway, and who
won't even spend 5 minutes on reading the tutorial to the syntax.

This is also how Google works: you don't have to have an idea how it
works: you just type words and go through the results that may or may
not be what you wanted. In the field of Internet search we don't have
a better alternative unfortunately; we don't have massive semantic
information that would allow us to find exactly the information.

== Conclusion ==

I develop Hk for people who do have 5 minutes to spend on a syntax
format tutorial and not for people who don't care. It is not an
enterprise software, after all, but an open source project. I think we
should follow the first model that I described. For example, we should
not make Hk support all possible itemizations -- it is enough if it
supports the itemizations we use. It others want to use Hk, they can
use those. The alternative would be even worse: everybody can use the
itemizations they like and hope that Hk will process it well.

[1] heap://2080
[2] heap://2081
[3] I dislike MS Office, OpenOffice and Google Docs. They all try to
    find out what I want to do and they all fail and make horrible
    things when I for example hit "backspace" in the beginning of a
    line or paragraph.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/354 -->
<span class="postsummary" id="post_hh/354">
<span class="author">Attila Nagy</span>
<span class="subject">Post syntax matched to user needs</span>
<span class="tags">[+prop, -discussion]</span>
<span class="index"><a href="../hh/thread_156.html#post_hh/354">&lt;hh/354&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/345">&lt;&uarr;hh/345&gt;</a></span>
<span class="date">(2009-05-31)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; I develop Hk for people who do have 5 minutes to spend on a syntax
&gt; format tutorial and not for people who don't care. It is not an
&gt; enterprise software, after all, but an open source project. I think we
&gt; should follow the first model that I described. For example, we should
&gt; not make Hk support all possible itemizations -- it is enough if it
&gt; supports the itemizations we use. It others want to use Hk, they can
&gt; use those. The alternative would be even worse: everybody can use the
&gt; itemizations they like and hope that Hk will process it well.

</span></span>I imagine Hk's role in a slightly different way. I think it should aim
to be a drop-in replacement for a traditional mailing list. The fact
that it has an editable archive and a nice and usable HTML output
should not affect the way people write emails to a list. People who
just write to a list to ask a question from the members, and couldn't
care less about the maintainers and the archive, will be annoyed when
faced the fact that this list is different, and you can't follow your
customs when posting here.

I therefore propose that Heapkeeper should have alternate syntaxes for
post bodies. For those heaps that want to take advantage of all
advanced features, all the syntax described up to now would be in
effect, including bracket-delimited metas and advanced itemizations.
Where users demand a traditional mailing list behavior, all body
parsing could be turned off, maybe with the exception of turning URLs
into links. There could also be an intermediate level, where all metas
would work, but with a harder-to-misuse notation, which could be the
old triple-angle-bracket format.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/359 -->
<span class="postsummary" id="post_hh/359">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/359">&lt;hh/359&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/354">&lt;&uarr;hh/354&gt;</a></span>
<span class="date">(2009-05-31)</span>
<div class="body">
<pre class="postbody">OK.

But don't forget: when the body parsing is turned off, you have to
display the newline characters in the HTML. So the post pages won't be
much nicer then the pages of any other archive. Although we will have
tags, index pages, hkshell for modifying the heap; having nice post
pages is not our only merit.

I don't see much point in having an intermediate post syntax now.
Maybe in the future. Now we should concentrate on the "advanced
syntax".

What do you think should be the default behaviour? Parsing turned off
or on? That's also important from the tutorial's point of view. (Not
the current tutorial of course.)
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/367 -->
<span class="postsummary" id="post_hh/367">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/367">&lt;hh/367&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/359">&lt;&uarr;hh/359&gt;</a></span>
<span class="date">(2009-06-01)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; I don't see much point in having an intermediate post syntax now.
&gt; Maybe in the future. Now we should concentrate on the "advanced
&gt; syntax".

</span></span>OK.

<span class="quote"><span class="quote-1">&gt; What do you think should be the default behaviour? Parsing turned off
&gt; or on? That's also important from the tutorial's point of view. (Not
&gt; the current tutorial of course.)

</span></span>Maybe we should default to on, to show the world the best we can do,
while keeping it strongly emphasized that it can be turned off.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/369 -->
<span class="postsummary" id="post_hh/369">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/369">&lt;hh/369&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/367">&lt;&uarr;hh/367&gt;</a></span>
<span class="date">(2009-06-01)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-2">&gt;&gt; What do you think should be the default behaviour? Parsing turned off
&gt;&gt; or on? That's also important from the tutorial's point of view. (Not
&gt;&gt; the current tutorial of course.)
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Maybe we should default to on, to show the world the best we can do,
&gt; while keeping it strongly emphasized that it can be turned off.

</span></span>OK.
</pre></div>
</span><!-- postsummary -->
</div><!-- postbox for post hh/369 -->
</div><!-- postbox for post hh/367 -->
</div><!-- postbox for post hh/359 -->
</div><!-- postbox for post hh/354 -->
</div><!-- postbox for post hh/345 -->
</div><!-- postbox for post hh/341 -->
</div><!-- postbox for post hh/338 -->
</div><!-- postbox for post hh/337 -->
</div><!-- postbox for post hh/335 -->

<div class="postbox"><!-- post hh/336 -->
<span class="postsummary" id="post_hh/336">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/336">&lt;hh/336&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/332">&lt;&uarr;hh/332&gt;</a></span>
<span class="date">(2009-05-29)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-2">&gt;&gt; &lt;&lt;&lt;!todo Rather "do without"&gt;&gt;&gt;
&gt;&gt; ...
&gt;&gt; [!todo We should change "cite" to "footnote".]
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; I guess this was the point where you were convinced to use brackets
&gt; instead of the old meta syntax :) Seven lines earlier you used the old
&gt; meta syntax, here you use a bracket segment.

</span></span>I couldn't wait for our dog food to be ready. :)

== Quotes ==

<span class="quote"><span class="quote-2">&gt;&gt; Here, you have a guarantee that the depth of the recursion will not
&gt;&gt; exceed the depth of the quotation, which I'd like not to exceed 20 in
&gt;&gt; any reasonable conversation.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; You don't know how long discussions our users will have on their heaps.

</span></span>That's why the wording was so careful.

<span class="quote"><span class="quote-1">&gt; How much simpler can it get? It would be more difficult if we used
&gt; hierarchical quotes.
&gt;
</span></span><span class="quote"><span class="quote-2">&gt;&gt; But since we probably don't want to do this,
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; I do :)

</span></span>OK :)

<span class="quote"><span class="quote-2">&gt;&gt; I'm being swayed towards flat representation. Simple representation
&gt;&gt; is probably better than simple algorithm, at least that's what
&gt;&gt; Heapkeeper's evolution has been about so far.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; True, that could be one of our design principle. In this particular
&gt; case, however, simple representation means simple algorithm.

</span></span>Flat it is, then.

== Authors and signatures ==

<span class="quote"><span class="quote-3">&gt;&gt;&gt; Why should we generate signature?
</span></span><span class="quote"><span class="quote-2">&gt;&gt;
&gt;&gt; Ummm...
&gt;&gt;
</span></span><span class="quote"><span class="quote-3">&gt;&gt;&gt; Maybe we should not sign our emails at all and should not generate
&gt;&gt;&gt; signatures in posts.
</span></span><span class="quote"><span class="quote-2">&gt;&gt;
&gt;&gt; But since it wouldn't be hard, why not make it possible?
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Because it is not useful? :D
&gt;
&gt; Joke aside, if you would like to see this feature, go for it, as I
&gt; said previously.

</span></span>I guess I will, but with a low priority.

== Quotes again ==

<span class="quote"><span class="quote-1">&gt; (I have a feeling that you argued in your mail for hierarchical
&gt; storing of quotes _before_ you actually read the end of my email where
&gt; I explain how would I actually store quotes.)

</span></span>Not impossible. Since I almost failed to notice one of the most important
parts of your post, nothing can surprise me. Vim folding (or rather my
being addicted to it) is to blame :)

== Modularity, parser steps (was: Wiki-like headers) ==

<span class="quote"><span class="quote-2">&gt;&gt; OK by me. But what would we do if the Dissector creates Quote segments,
&gt;&gt; and the Parser stack contains no module to process them?
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; *Sigh*. There are no "quote segments". See again above and in my
&gt; proposal on what segments do I envision.

</span></span>I guess you may be right about my not reading your whole post before
replying. My bad.

On the other hand, it was just an example. The question in a generic
form:

But what would we do if the Dissector creates Xyz segments, and the
Parser stack contains no module to process them?

== Posts we have ==

<span class="quote"><span class="quote-1">&gt; Just kidding. We will see if we want to have some automatism when we
&gt; have done a few posts by hand.

</span></span>Of course. But don't overdo it: almost all the old posts require hand
labor anyway for non-automatable reasons, like excessive quoting,
mistyping, outdated information and the like.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/339 -->
<span class="postsummary" id="post_hh/339">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/339">&lt;hh/339&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/336">&lt;&uarr;hh/336&gt;</a></span>
<span class="date">(2009-05-29)</span>
<div class="body">
<pre class="postbody">== Quotes ==

<span class="quote"><span class="quote-3">&gt;&gt;&gt; Here, you have a guarantee that the depth of the recursion will not
&gt;&gt;&gt; exceed the depth of the quotation, which I'd like not to exceed 20 in
&gt;&gt;&gt; any reasonable conversation.
</span></span><span class="quote"><span class="quote-2">&gt;&gt; You don't know how long discussions our users will have on their heaps.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; That's why the wording was so careful.

</span></span>And that's why your statement means nothing...

== Modularity, parser steps (was: Wiki-like headers) ==

<span class="quote"><span class="quote-3">&gt;&gt;&gt; OK by me. But what would we do if the Dissector creates Quote segments,
&gt;&gt;&gt; and the Parser stack contains no module to process them?
</span></span><span class="quote"><span class="quote-2">&gt;&gt; *Sigh*. There are no "quote segments". See again above and in my
&gt;&gt; proposal on what segments do I envision.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; I guess you may be right about my not reading your whole post before
&gt; replying. My bad.
&gt;
&gt; On the other hand, it was just an example. The question in a generic
&gt; form:
&gt;
&gt; But what would we do if the Dissector creates Xyz segments, and the
&gt; Parser stack contains no module to process them?

</span></span>I guess the HTML-generator modul has to deal with any kind of segment.
Probably the reasonable thing to do is to print the unknown segments
with a different color which indicates a problem.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/340 -->
<span class="postsummary" id="post_hh/340">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/340">&lt;hh/340&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/339">&lt;&uarr;hh/339&gt;</a></span>
<span class="date">(2009-05-29)</span>
<div class="body">
<pre class="postbody">== Quotes ==

<span class="quote"><span class="quote-4">&gt;&gt;&gt;&gt; Here, you have a guarantee that the depth of the recursion will not
&gt;&gt;&gt;&gt; exceed the depth of the quotation, which I'd like not to exceed 20 in
&gt;&gt;&gt;&gt; any reasonable conversation.
</span></span><span class="quote"><span class="quote-3">&gt;&gt;&gt; You don't know how long discussions our users will have on their heaps.
</span></span><span class="quote"><span class="quote-2">&gt;&gt;
&gt;&gt; That's why the wording was so careful.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; And that's why your statement means nothing...

</span></span>A common problem with careful wording. Though I really don't see
what's your problem with the depth of the recursion the processing
of quotes would mean. Of course, recursion is bad if its depth is
truly uncontrolled. But depth that is reached by "human methods", i.e.
replying to replies, will hardly ever reach a problematic range. Now
if a malevolent user sends a mail filled with millions of '&gt;'s, that's
another problem.

== Modularity, parser steps (was: Wiki-like headers) ==

<span class="quote"><span class="quote-4">&gt;&gt;&gt;&gt; OK by me. But what would we do if the Dissector creates Quote segments,
&gt;&gt;&gt;&gt; and the Parser stack contains no module to process them?
</span></span><span class="quote"><span class="quote-3">&gt;&gt;&gt; *Sigh*. There are no "quote segments". See again above and in my
&gt;&gt;&gt; proposal on what segments do I envision.
</span></span><span class="quote"><span class="quote-2">&gt;&gt;
&gt;&gt; I guess you may be right about my not reading your whole post before
&gt;&gt; replying. My bad.
&gt;&gt;
&gt;&gt; On the other hand, it was just an example. The question in a generic
&gt;&gt; form:
&gt;&gt;
&gt;&gt; But what would we do if the Dissector creates Xyz segments, and the
&gt;&gt; Parser stack contains no module to process them?
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; I guess the HTML-generator modul has to deal with any kind of segment.
&gt; Probably the reasonable thing to do is to print the unknown segments
&gt; with a different color which indicates a problem.

</span></span>OK, I think we can do this.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/348 -->
<span class="postsummary" id="post_hh/348">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/348">&lt;hh/348&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/340">&lt;&uarr;hh/340&gt;</a></span>
<span class="date">(2009-05-29)</span>
<div class="body">
<pre class="postbody">== Quotes ==

<span class="quote"><span class="quote-5">&gt;&gt;&gt;&gt;&gt; Here, you have a guarantee that the depth of the recursion will not
&gt;&gt;&gt;&gt;&gt; exceed the depth of the quotation, which I'd like not to exceed 20 in
&gt;&gt;&gt;&gt;&gt; any reasonable conversation.
</span></span><span class="quote"><span class="quote-4">&gt;&gt;&gt;&gt; You don't know how long discussions our users will have on their heaps.
</span></span><span class="quote"><span class="quote-3">&gt;&gt;&gt; That's why the wording was so careful.
</span></span><span class="quote"><span class="quote-2">&gt;&gt; And that's why your statement means nothing...
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; A common problem with careful wording. Though I really don't see
&gt; what's your problem with the depth of the recursion the processing
&gt; of quotes would mean. Of course, recursion is bad if its depth is
&gt; truly uncontrolled. But depth that is reached by "human methods", i.e.
&gt; replying to replies, will hardly ever reach a problematic range.

</span></span>Maybe someone will use a heap entirely differently from us. Maybe they
will have a thread to which all team members should report the result
of their daily work.

<span class="quote"><span class="quote-1">&gt; Now if a malevolent user sends a mail filled with millions of '&gt;'s,
&gt; that's another problem.

</span></span>I haven't even realized this problem...
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/349 -->
<span class="postsummary" id="post_hh/349">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/349">&lt;hh/349&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/348">&lt;&uarr;hh/348&gt;</a></span>
<span class="date">(2009-05-30)</span>
<div class="body">
<pre class="postbody">== Quotes ==

<span class="quote"><span class="quote-6">&gt;&gt;&gt;&gt;&gt;&gt; Here, you have a guarantee that the depth of the recursion will not
&gt;&gt;&gt;&gt;&gt;&gt; exceed the depth of the quotation, which I'd like not to exceed 20 in
&gt;&gt;&gt;&gt;&gt;&gt; any reasonable conversation.
</span></span><span class="quote"><span class="quote-5">&gt;&gt;&gt;&gt;&gt; You don't know how long discussions our users will have on their heaps.
</span></span><span class="quote"><span class="quote-1">&gt; Maybe someone will use a heap entirely differently from us. Maybe they
&gt; will have a thread to which all team members should report the result
&gt; of their daily work.

</span></span>All right. Flat structure, flat algorithm.
</pre></div>
</span><!-- postsummary -->
</div><!-- postbox for post hh/349 -->
</div><!-- postbox for post hh/348 -->
</div><!-- postbox for post hh/340 -->
</div><!-- postbox for post hh/339 -->
</div><!-- postbox for post hh/336 -->
</div><!-- postbox for post hh/332 -->
</div><!-- postbox for post hh/330 -->

<div class="postbox"><!-- post hh/621 -->
<span class="postsummary" id="post_hh/621">
<span class="author">Attila Nagy</span>
<span class="subject">The principle of expanding syntax; example</span>
<span class="tags">[-post syntax]</span>
<span class="index"><a href="../hh/thread_156.html#post_hh/621">&lt;hh/621&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/308">&lt;&uarr;hh/308&gt;</a></span>
<span class="date">(2009-10-02)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; Thus I formulate a basic principle which makes backward compatibility
&gt; not so difficult to achieve. The basic principle of creating the
&gt; syntax and semantics of posts should be the following. We have to make
&gt; an initial ruleset that states clearly what is a syntactically and
&gt; semantically correct post. The syntax and semantics of those posts
&gt; should _never_ change. The way we can add more features: we change the
&gt; ruleset so that posts there were previously syntactically or
&gt; semantically incorrect will become correct. These posts refer to new
&gt; features that were introduced with the change of the ruleset. The post
&gt; syntax/semantics can evolve continuously, as we turn more and more
&gt; previously incorrect posts to correct ones. Of course we will never
&gt; run out of incorrect posts -- they are infinite in number.

</span></span>Well said. Let's call this the "principle of expanding syntax".

<span class="quote"><span class="quote-1">&gt; === Example of the principle not working ===
&gt;
&gt; I'll give an example that does not respect the principle.
&gt;
&gt; Consider we convert [</span></span><span class="quote"><span class="quote-1"><a href="http://link">http://link</a></span></span><span class="quote"><span class="quote-1"> text] (\[</span></span><span class="quote"><span class="quote-1"><a href="http://.\{-}\]">http://.\{-}\]</a></span></span><span class="quote"><span class="quote-1">) into an
&gt; HTML link, but we accept anything else as normal text. We release a
&gt; version of Hk that works this way. Then we realize sometimes we want
&gt; to write lines like this:
&gt;
&gt;     My favourite author is [</span></span><span class="quote"><span class="quote-1"><a href="http://en.wikipedia.org/wiki/Isaac_Asimov">http://en.wikipedia.org/wiki/Isaac_Asimov</a></span></span><span class="quote"><span class="quote-1">
&gt;     Isaac Asimov, the genius.]
&gt;
&gt; But we can't go back without cheating, because we said this was a
&gt; syntactically/semantically correct text already!

</span></span>I don't understand your example. How is the example line different
from \[<a href="http://link">http://link</a> text]? Also what does "we accept anything else as
normal text" mean?
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/625 -->
<span class="postsummary" id="post_hh/625">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/625">&lt;hh/625&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/621">&lt;&uarr;hh/621&gt;</a></span>
<span class="date">(2009-10-02)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-2">&gt;&gt; Thus I formulate a basic principle which makes backward compatibility
&gt;&gt; not so difficult to achieve. The basic principle of creating the
&gt;&gt; syntax and semantics of posts should be the following. We have to make
&gt;&gt; an initial ruleset that states clearly what is a syntactically and
&gt;&gt; semantically correct post. The syntax and semantics of those posts
&gt;&gt; should _never_ change. The way we can add more features: we change the
&gt;&gt; ruleset so that posts there were previously syntactically or
&gt;&gt; semantically incorrect will become correct. These posts refer to new
&gt;&gt; features that were introduced with the change of the ruleset. The post
&gt;&gt; syntax/semantics can evolve continuously, as we turn more and more
&gt;&gt; previously incorrect posts to correct ones. Of course we will never
&gt;&gt; run out of incorrect posts -- they are infinite in number.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Well said. Let's call this the "principle of expanding syntax".
&gt;
</span></span><span class="quote"><span class="quote-2">&gt;&gt; === Example of the principle not working ===
&gt;&gt;
&gt;&gt; I'll give an example that does not respect the principle.
&gt;&gt;
&gt;&gt; Consider we convert [</span></span><span class="quote"><span class="quote-2"><a href="http://link">http://link</a></span></span><span class="quote"><span class="quote-2"> text] (\[</span></span><span class="quote"><span class="quote-2"><a href="http://.\{-}\]">http://.\{-}\]</a></span></span><span class="quote"><span class="quote-2">) into an
&gt;&gt; HTML link, but we accept anything else as normal text. We release a
&gt;&gt; version of Hk that works this way. Then we realize sometimes we want
&gt;&gt; to write lines like this:
&gt;&gt;
&gt;&gt;     My favourite author is [</span></span><span class="quote"><span class="quote-2"><a href="http://en.wikipedia.org/wiki/Isaac_Asimov">http://en.wikipedia.org/wiki/Isaac_Asimov</a></span></span><span class="quote"><span class="quote-2">
&gt;&gt;     Isaac Asimov, the genius.]
&gt;&gt;
&gt;&gt; But we can't go back without cheating, because we said this was a
&gt;&gt; syntactically/semantically correct text already!
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; I don't understand your example. How is the example line different
&gt; from \[</span></span><span class="quote"><span class="quote-1"><a href="http://link">http://link</a></span></span><span class="quote"><span class="quote-1"> text]?

</span></span>It contains a newline character after the link and before the text. The pattern
"[<a href="http://en.wikipedia.org/wiki/Isaac_Asimov\n">http://en.wikipedia.org/wiki/Isaac_Asimov\n</a> Isaac Asimov, the genius.]" does
not match the regexp \[<a href="http://.\{-}\]">http://.\{-}\]</a>, because '.' usually means "any
character but
newline".

<span class="quote"><span class="quote-1">&gt; Also what does "we accept anything else as normal text" mean?

</span></span>It means that if a text does not match the \[<a href="http://.\{-}\]">http://.\{-}\]</a> regexp,
then we accept it
as syntactically correct, usual, normal text. Since
"[<a href="http://en.wikipedia.org/wiki/Isaac_Asimov\n">http://en.wikipedia.org/wiki/Isaac_Asimov\n</a> Isaac Asimov, the genius.]" does
not match that regexp, we would (in my example) accept it as normal,
syntactically
correct text.
</pre></div>
</span><!-- postsummary -->
</div><!-- postbox for post hh/625 -->
</div><!-- postbox for post hh/621 -->
</div><!-- postbox for post hh/308 -->
</div><!-- postbox for post hh/301 -->
</div><!-- postbox for post hh/246 -->

<div class="postbox"><!-- post hh/267 -->
<span class="postsummary" id="post_hh/267">
<span class="author">Csaba Hoch</span>
<span class="subject">Body parsing - the what - cites</span>
<span class="index"><a href="../hh/thread_156.html#post_hh/267">&lt;hh/267&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/232">&lt;&uarr;hh/232&gt;</a></span>
<span class="date">(2009-05-19)</span>
<div class="body">
<pre class="postbody">&lt;&lt;&lt;wiki&gt;&gt;&gt;

== Footnotes ==

<span class="quote"><span class="quote-1">&gt; == Cites ==

</span></span>=== Wording ===

We agreed to use the word "footnote" instead of "cite". We also agreed
on using the word "footnote-body". We may use also "footnote head" if
you think so. Another think: maybe "footnote body" would be better
without a hyphen.

=== Multi-line footnotes ===

Do we allow multi-line footnotes? I'm very much in favour of them.

=== Exact definition of footnote-body ===

However, we have to think about how to define what a footnote-body is.
Consider this text:

    Someone told me that Isaac Asimov was a very good book writer
    [1]. Thus I bought all his books.

    Arthur

    [1] <a href="http://verygoodbooks.org">http://verygoodbooks.org</a>

Csabi

[1] <a href="../hh/thread_5.html#post_hh/5">heap://hh/5</a>
</pre></div>
</span><!-- postsummary -->
</div><!-- postbox for post hh/267 -->

<div class="postbox"><!-- post hh/377 -->
<span class="postsummary" id="post_hh/377">
<span class="author">Attila Nagy</span>
<span class="subject">Problem with quoted raw lines</span>
<span class="index"><a href="../hh/thread_156.html#post_hh/377">&lt;hh/377&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/232">&lt;&uarr;hh/232&gt;</a></span>
<span class="date">(2009-06-05)</span>
<div class="body">
<pre class="postbody">All this time we've been missing a rather obvious problem.

We defined a raw line as beginning with a whitespace, and a raw line
as beginning with at least one quote leading character, ie. '&gt;'.

However, we _always_ wrote quoted normal lines (that is, quoted
non-raw lines) starting with '&gt; '.

This means the naive approach to trim any number of '&gt;'s from the start
of the lines, and then check if the remainder starts with a whitespace
character or not, fails miserably, since all lines will start with
whitespace once stripped of the '&gt;'s.

Therefore, I recommend the following rules for parsing:[-]
- if the line starts with a '&gt;':
    - the line is part of a quoted segment
    - get and count all the '&gt;'s, and strip them from the string
    - if the next character is a space, strip it
    - continue to the next step
- if the line (or what's left of it) starts with whitespace:
    - strip exactly one space
    - treat the rest as raw
- else the line is normal, and part of a paragraph

To sum it up, this:

    &gt;hello

would be normal, quote level 1, this:

    &gt; hello

would also be normal, quote level 1, while this:

    &gt;  hello

would be raw, quote level 1.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/378 -->
<span class="postsummary" id="post_hh/378">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_156.html#post_hh/378">&lt;hh/378&gt;</a></span>
<span class="parent"><a href="../hh/thread_156.html#post_hh/377">&lt;&uarr;hh/377&gt;</a></span>
<span class="date">(2009-06-06)</span>
<div class="body">
<pre class="postbody">Yes, you describe the same principle ("first space in quote does not
count") that I thought we should use.
</pre></div>
</span><!-- postsummary -->
</div><!-- postbox for post hh/378 -->
</div><!-- postbox for post hh/377 -->
</div><!-- postbox for post hh/232 -->
</div><!-- postbox for post hh/156 -->

  </body>
</html>
