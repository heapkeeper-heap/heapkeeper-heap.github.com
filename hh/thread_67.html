<!-- Generated by Heapkeeper v0.4 on 2010-04-10 13:44:39 -->
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>Thread hh/67</title>
    <link rel=stylesheet href="../heapindex.css" type="text/css">
  </head>
  <body>
    <h1 id="header">Thread hh/67</h1>


<div class="postbox"><!-- post hh/67 -->
<span class="postsummary" id="post_hh/67">
<span class="author">Csaba Hoch</span>
<span class="subject">Renaming the github repository to "heapmanipulator" (later "heapkeeper")</span>
<span class="tags">[prop, reviewed]</span>
<span class="index"><a href="../hh/thread_67.html#post_hh/67">&lt;hh/67&gt;</a></span>
<span class="parent">&lt;root&gt;</span>
<span class="date">(2009-04-05)</span>
<div class="body">
<pre class="postbody">There is a simple "rename repository" textbox on the admin area.
Do you agree that we should rename the repo?
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/68 -->
<span class="postsummary" id="post_hh/68">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_67.html#post_hh/68">&lt;hh/68&gt;</a></span>
<span class="parent"><a href="../hh/thread_67.html#post_hh/67">&lt;&uarr;hh/67&gt;</a></span>
<span class="date">(2009-04-05)</span>
<div class="body">
<pre class="postbody">No.

Somehow I find the idea of naming the whole project "Heapmanipulator"
unattractive. We invented the concept of heap, and we have a
manipulator to handle that, that's true, but I feel the concept is
more central to the project than the program.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/69 -->
<span class="postsummary" id="post_hh/69">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_67.html#post_hh/69">&lt;hh/69&gt;</a></span>
<span class="parent"><a href="../hh/thread_67.html#post_hh/68">&lt;&uarr;hh/68&gt;</a></span>
<span class="date">(2009-04-05)</span>
<div class="body">
<pre class="postbody">You could elaborate on that. Choosing a good name is very important;
let's have discussion about it.

IIUC, you accept that Heapmanipulator is a better name for the
_program_ than Heap, you just don't agree that it is better for the
_project_.

I like the name Heapmanipulator more than Heap even for the project,
because it is unique. E.g. the domains heap.com and heap.org do exist.
It is practically impossible to find information about a program or
project called Heap. "Heap project" raises 1390 hits on Google, "heap
program" raises 7340. There are even a very few hits for "heap
manipulator": someone wrote a Heap Manipulator in Java to manipulate
the heap data structure. If we want a decent project homepage, its
address could be heapmanipulator.org; but it will not be heap.org. (It
could be e.g. heapproject.org, though.)

Maybe we should talk about the distinction between the project and the
program. What other things are in the project in your opinion? The
research? :) The web-Hm? I thought the web-Hm would also be called
Heapmanipulator. (But I don't have a strong opinion on this.)

Is it worth at all to draw any distinction between the program and the
project? I can hardly think of any project that did that; besides the
GNU project, which of course contains hundreds of programs [1] and
other stuff like licenses.

I'm very interested in reading what you think.

[1] <a href="http://directory.fsf.org/GNU/">http://directory.fsf.org/GNU/</a>
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/70 -->
<span class="postsummary" id="post_hh/70">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_67.html#post_hh/70">&lt;hh/70&gt;</a></span>
<span class="parent"><a href="../hh/thread_67.html#post_hh/69">&lt;&uarr;hh/69&gt;</a></span>
<span class="date">(2009-04-05)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; I like the name Heapmanipulator more than Heap even for the project,
&gt; because it is unique. E.g. the domains heap.com and heap.org do exist.
&gt; It is practically impossible to find information about a program or
&gt; project called Heap.

</span></span>A strong point.

<span class="quote"><span class="quote-1">&gt; Maybe we should talk about the distinction between the project and the
&gt; program. What other things are in the project in your opinion? The
&gt; research? :) The web-Hm? I thought the web-Hm would also be called
&gt; Heapmanipulator. (But I don't have a strong opinion on this.)

</span></span>The web interface, as I see it, will be the kind of interface to a
heap that doesn't exist today: a single interface to view and
manipulate the heap. As long as the Heap is manipulated and viewed on
separate interfaces, I find the name 'Heapmanipulator' for the former
appropriate. But when the unification will have yielded the Grand
Unified Web Interface to a heap, I think its name should be a broader
term than just "Heapmanipulator".

<span class="quote"><span class="quote-1">&gt; Is it worth at all to draw any distinction between the program and the
&gt; project?

</span></span>Sometimes it is. Some projects build programs, like, say, Gimp. Others
build suites of programs, like OpenOffice or Mozilla. (Of these, I
think only the latter produces distinct binaries for the individual
members of the suite.) I imagine our project, the name of which is
being debated, will produce a suite consisting of:
- a documented format for a mutable mailing list (called a heap)
- a library for editing of said list (called Heapmanipulator)
- a simple interactive interface for said library (called Heapia)
- a Web-based interface for the same library (no name yet; Heapweb?)

If we want to maintain clarity, the name of the suite should be
identical to none of its constituents. (Mozilla used to violate this
before its (now I think least used) umbrella product became
SeaMonkey.) Yet, my idea of name usage had the same word for the
project as the data structure on which it is built, namely "heap",
albeit with different capitalization.

Possible names for the project: (Warning: not all of this I consider a
serious proposal; finding the ones worth of attention it is left as an
exercise to the reader.)
- Heap: only the capitalization makes it distinct from the name of the
  data structure
- Heap Project: a bit schoolish
- Project Heap: a bit of post-industrial buzz, also military-lookalike-ish
- HEAP Editable Archive of Posts: a bit of GNU insider humor, but
  doesn't make us easier to find
- Heap Suite: probably sensible at a later stage, but we need a name
  now, and it would be pretty boastful right now
- Heep: means nothing [1], and probably the best solution to the
  findability problem; together with an appropriately-designed
  pastel-rounded-reflect-fonted logo, its misspellinged cuteness makes
  for a good name in the Web 2.0 naming epoch; other than that (ie.
  for that) I hate it
- Digger: a digger is something that builds a heap, isn't it? but
  probably a very common word
- Heapkeeper: I like this probably the most; it satisfies the
  generality criterion, and Googlable, now has only 127 hits
- Heepkeep: same, but even more Google-friendly at 2 hits

Conclusion: I'm not really fond of any alternatives I could think of,
but maybe you can add more. There is a workaround to be able to keep
Heap as a name for the project: rename the data structure to something
else (heapstore?). This doesn't solve the Google/findability issue,
though.

What do you think of my neologisms? (If none of them pleases you, I
guess I'll submit to using Heapmanipulator.)

[1] <a href="http://www.google.hu/search?q=heep+-uriah">http://www.google.hu/search?q=heep+-uriah</a>
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/71 -->
<span class="postsummary" id="post_hh/71">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_67.html#post_hh/71">&lt;hh/71&gt;</a></span>
<span class="parent"><a href="../hh/thread_67.html#post_hh/70">&lt;&uarr;hh/70&gt;</a></span>
<span class="date">(2009-04-08)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-2">&gt;&gt; Is it worth at all to draw any distinction between the program and the
&gt;&gt; project?
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Sometimes it is. Some projects build programs, like, say, Gimp. Others
&gt; build suites of programs, like OpenOffice or Mozilla. (Of these, I
&gt; think only the latter produces distinct binaries for the individual
&gt; members of the suite.) I imagine our project, the name of which is
&gt; being debated, will produce a suite consisting of:
&gt; - a documented format for a mutable mailing list (called a heap)
&gt; - a library for editing of said list (called Heapmanipulator)
&gt; - a simple interactive interface for said library (called Heapia)
&gt; - a Web-based interface for the same library (no name yet; Heapweb?)

</span></span>I think the users should see only one program (with one name, which is
the same as the project's name), which has different features and can
be used on different ways. The developers can still think of the
program as different modules -- some of them API, some of them console
interface, some of them dynamic web interface.

<span class="quote"><span class="quote-1">&gt; - Digger: a digger is something that builds a heap, isn't it? but
&gt; probably a very common word

</span></span>I think it makes a hole as its main task; the heap is just a
side effect.

<span class="quote"><span class="quote-1">&gt; - Heapkeeper: I like this probably the most; it satisfies the
&gt; generality criterion, and Googlable, now has only 127 hits

</span></span>I like it. First I didn't, because it reminds me to "Bitkeeper".
I think our whole program (web and console interface, parser,
everything included) should be named Heapkeeper.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/81 -->
<span class="postsummary" id="post_hh/81">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_67.html#post_hh/81">&lt;hh/81&gt;</a></span>
<span class="parent"><a href="../hh/thread_67.html#post_hh/71">&lt;&uarr;hh/71&gt;</a></span>
<span class="date">(2009-04-13)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-3">&gt;&gt;&gt; Maybe we should talk about the distinction between the project and the
&gt;&gt;&gt; program. What other things are in the project in your opinion? The
&gt;&gt;&gt; research? :) The web-Hm? I thought the web-Hm would also be called
&gt;&gt;&gt; Heapmanipulator. (But I don't have a strong opinion on this.)

</span></span><span class="quote"><span class="quote-2">&gt;&gt; The web interface, as I see it, will be the kind of interface to a
&gt;&gt; heap that doesn't exist today: a single interface to view and
&gt;&gt; manipulate the heap.

</span></span>Yes. But heapia could display the posts, as well. The ls command is
the first step into that direction.

<span class="quote"><span class="quote-2">&gt;&gt; I imagine our project, the name of which is being debated, will
&gt;&gt; produce a suite consisting of:
&gt;&gt; - a documented format for a mutable mailing list (called a heap)

</span></span>Well... I'm not sure that the current format with many-many small
files is our final choice. We might even use database tables to store
the posts. Especially in the web-Hm. Maybe we will have two formats:
- internal, efficient representation: database tables
- external, human-readable, easy-to-parse, exportable and importable
representation: the current mail file format, XML or YAML.

Now the internal format is in the memory in the form of a MailDB
object. Maybe that is the right choice, not a traditional database.
I'm not saying what will happen; I'm just saying many things can
happen.

For me "heap" is not a concrete format but rather an abstract one.
Like the expression "mailing list". The difference is that a heap has
posts instead of emails, and it has tags and meta text. (There may be
more differences, that's not the point.) The similarity is that both
have parent-children relationships, and threaded structure based on
these. Neither "heap" nor "mailing list" say how the posts/emails
shall be stored: they are just abstract concepts.

<span class="quote"><span class="quote-1">&gt; - a library for editing of said list (called Heapmanipulator)
&gt; - a simple interactive interface for said library (called Heapia)

</span></span>I don't think of these as separate programs. Maybe when the web-Hm is
ready, we will have to think of them as separate entities. On the
other hand, we don't want to confuse users by telling them about a
bunch of different names when actually what now exists is just one
traditional software program and nothing else. E.g. Sphinx does have
different generators (HTML, LaTeX, etc.), a common parser (which is
from another project called reStructuredText), an extension system,
and some extensions that it ships with (e.g. one called autodoc that
extracts doctrings from Python modules). Yet, they don't confuse
users: the project and the program are both called Sphinx, end of
story. (OK, I admit, they mention reStructuredText, but that's all.)

Similarly, we could say we have a program called Hm, which has a
console and a web interface, end of story. I think the users would be
most happy with that solution. They don't care about the modules
structure and things like that.

Another example is git. Linus's philosophy was that it is a set of
tools (e.g. git-commit, git-checkout, etc.) that operate on a common
database. But the users didn't like this philosophy: they didn't want
a bunch of separate programs (which "polluted their bin directory").
Now the philosophy is that git is one program with many subcommands
(e.g. "git commit", "git checkout"), and invoking "git-commit" is
deprecated. The Unix philosophy with orthogonal tools is a good one,
but one should use it only when appropriate -- and in most cases it is
not. It is not appropriate in git's case and it is not appropriate in
our case.

<span class="quote"><span class="quote-1">&gt; - a Web-based interface for the same library (no name yet; Heapweb?)

</span></span>Well, if the name of the console interface is heapia, the name of the
web-interface could be heapweb.

<span class="quote"><span class="quote-1">&gt; If we want to maintain clarity, the name of the suite should be
&gt; identical to none of its constituents.

</span></span>True.

So my proposal is having only these concepts that require a name:

- "heap": the abstract structure and the database that stores it
(regardless of the method of storage).

- "Heapkeeper": the name of the whole program, the name of the
  project, the name of the website, the name of the repository, the
  name of the mailing list -- sorry, the name of the heap :D

- "heapia" or "interactive console interface": the console interface
  of Heapkeeper. The user will think it is the "./heapia" shell script
  (or heapia.bat for windows users...), or it is at least started by
  that script.

- "heapweb" or "web interface": modules that allow using Heapkeeper
  via the web. Since we don't know how we will do this, we don't know
  if this will be one module like heapia, or many modules, or even
  some XML files, or something else.

<span class="quote"><span class="quote-2">&gt;&gt; - Heapkeeper: I like this probably the most; it satisfies the
&gt;&gt; generality criterion, and Googlable, now has only 127 hits
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; I like it. First I didn't, because it reminds me to "Bitkeeper".
&gt; I think our whole program (web and console interface, parser,
&gt; everything included) should be named Heapkeeper.

</span></span>Probably Heapkeeper is better than Heapmanipulator in the way that it
suggests a program that stores and manages the data, maintaining its
consistency and correctness.

Shall we call our program Heapkeeper then? Of course it will be
abbreviated as Hk. (Which is better than Hm.)

If yes, then I will rename the github repository to "heapkeeper".
I'll create a heapkeeper.heap GMail account and a heapkeeper-heap
Google Group (although I think we won't use it until Hk supports
managing multiple heaps.)
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/84 -->
<span class="postsummary" id="post_hh/84">
<span class="author">Attila Nagy</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="tags">[+ppc]</span>
<span class="index"><a href="../hh/thread_67.html#post_hh/84">&lt;hh/84&gt;</a></span>
<span class="parent"><a href="../hh/thread_67.html#post_hh/81">&lt;&uarr;hh/81&gt;</a></span>
<span class="date">(2009-04-13)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; The web interface, as I see it, will be the kind of interface to a
&gt; heap that doesn't exist today: a single interface to view and
&gt; manipulate the heap.

&gt; Yes. But heapia could display the posts, as well. The ls command is
&gt; the first step into that direction.

</span></span>You are right. We should keep the option of using a heap via command
line only open as long as possible, ie. forever.

<span class="quote"><span class="quote-3">&gt;&gt;&gt; - a documented format for a mutable mailing list (called a heap)

</span></span><span class="quote"><span class="quote-1">&gt; Well... I'm not sure that the current format with many-many small
&gt; files is our final choice. We might even use database tables to store
&gt; the posts. Especially in the web-Hm. Maybe we will have two formats:
&gt; - internal, efficient representation: database tables
&gt; - external, human-readable, easy-to-parse, exportable and importable
&gt; representation: the current mail file format, XML or YAML.

</span></span>I like this idea. Still, a heap will be a documented format, one of a
set of possibilities: mailfiles, XML, YAML, SQL...

A possible roadmap:
1. Mailfile-based Hk with static HTML output (nearing completion, only
   lacking body parsing, as I see it)
2. Mailfile-based Hk with Web interface
    - at this point, we'll very probably need a single server (back to
      Shrek?)
    - this will probably be the end of the distributed Git two-way
      pulling storage mechanism (not necessarily, though, we could
      have a discussion on this)
3. SQL-backed Hk with Web interface (with Mailfiles/XML/YAML
   import/export capability)

<span class="quote"><span class="quote-1">&gt; For me "heap" is not a concrete format but rather an abstract one.
&gt; Like the expression "mailing list". The difference is that a heap
&gt; has posts instead of emails, and it has tags and meta text. (There
&gt; may be more differences, that's not the point.) The similarity is
&gt; that both have parent-children relationships, and threaded structure
&gt; based on these. Neither "heap" nor "mailing list" say how the
&gt; posts/emails shall be stored: they are just abstract concepts.

</span></span>Thus, we have two things called 'heap':
- the idea of an editable mailing list and the associated terminology
- the syntax and semantics of header elements which I think will be
  independent of the storage mechanism

Should we distinguish these?

<span class="quote"><span class="quote-1">&gt; - a library for editing of said list (called Heapmanipulator)
&gt; - a simple interactive interface for said library (called Heapia)

&gt; I don't think of these as separate programs. Maybe when the web-Hm
&gt; is ready, we will have to think of them as separate entities. On the
&gt; other hand, we don't want to confuse users by telling them about a
&gt; bunch of different names when actually what now exists is just one
&gt; traditional software program and nothing else

&gt; Similarly, we could say we have a program called Hm, which has a
&gt; console and a web interface, end of story.

</span></span>For that, the name 'Heapkeeper' (abbr. Hk) would be best.

<span class="quote"><span class="quote-1">&gt; I think the users would be most happy with that solution.

</span></span>We are not yet at the point where we'd have 'ordinary' users ignoring
implementation details. Though, of course, it is our goal to have them
:)

<span class="quote"><span class="quote-1">&gt; Now the philosophy is that git is one program with many subcommands
&gt; (e.g. "git commit", "git checkout"), and invoking "git-commit" is
&gt; deprecated. The Unix philosophy with orthogonal tools is a good one,
&gt; but one should use it only when appropriate -- and in most cases it
&gt; is not. It is not appropriate in git's case and it is not
&gt; appropriate in our case.

</span></span>Avoiding "bin pollution" via subcommands and Unixish tool
orthogonality are orthogonal. You can (should) retain access to
junction points in the plumbing behind the uniform shining porcelain,
like git has. Eg. you have pull, but you still have fetch. (Is it a
good example? You're much better at Git than I am.)

<span class="quote"><span class="quote-2">&gt;&gt; - a Web-based interface for the same library (no name yet; Heapweb?

</span></span><span class="quote"><span class="quote-1">&gt; Well, if the name of the console interface is heapia, the name of the
&gt; web-interface could be heapweb.

</span></span>Agreed then.

<span class="quote"><span class="quote-1">&gt; So my proposal is having only these concepts that require a name:
&gt; - "heap": the abstract structure and the database that stores it
&gt; (regardless of the method of storage).
&gt; - "Heapkeeper": the name of the whole program, the name of the
&gt;  project, the name of the website, the name of the repository, the
&gt;  name of the mailing list -- sorry, the name of the heap :D
&gt; - "heapia" or "interactive console interface": the console interface
&gt;  of Heapkeeper. The user will think it is the "./heapia" shell script
&gt;  (or heapia.bat for windows users...), or it is at least started by
&gt;  that script.
&gt; - "heapweb" or "web interface": modules that allow using Heapkeeper
&gt;  via the web. Since we don't know how we will do this, we don't know
&gt;  if this will be one module like heapia, or many modules, or even
&gt;  some XML files, or something else.

</span></span>OK.

<span class="quote"><span class="quote-1">&gt;Shall we call our program Heapkeeper then? Of course it will be
&gt;abbreviated as Hk. (Which is better than Hm.)

</span></span>Hmm. This takes us back to the suit/non-suit problem above. What
binary(ies) or command(s) exactly do you propose to be called
Heapkeeper?

<span class="quote"><span class="quote-1">&gt; If yes, then I will rename the github repository to "heapkeeper".
&gt; I'll create a heapkeeper.heap GMail account and a heapkeeper-heap
&gt; Google Group (although I think we won't use it until Hk supports
&gt; managing multiple heaps.)

</span></span>The project name should be changed. What do you want to use these new
addresses for? Is this the new name for the place we want to migrate
the hh-part of the present-day Heap?
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/88 -->
<span class="postsummary" id="post_hh/88">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_67.html#post_hh/88">&lt;hh/88&gt;</a></span>
<span class="parent"><a href="../hh/thread_67.html#post_hh/84">&lt;&uarr;hh/84&gt;</a></span>
<span class="date">(2009-04-13)</span>
<div class="body">
<pre class="postbody"><span class="quote"><span class="quote-1">&gt; You are right. We should keep the option of using a heap via command
&gt; line only open as long as possible, ie. forever.

</span></span>:))

<span class="quote"><span class="quote-2">&gt;&gt; Did you write "Heapanipulator" intentionally?
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; No, but we can fall back to the expression if something goes
&gt; wrong...

</span></span>:)

<span class="quote"><span class="quote-4">&gt;&gt;&gt;&gt; - a documented format for a mutable mailing list (called a heap)
</span></span><span class="quote"><span class="quote-1">&gt;
</span></span><span class="quote"><span class="quote-2">&gt;&gt; Well... I'm not sure that the current format with many-many small
&gt;&gt; files is our final choice. We might even use database tables to store
&gt;&gt; the posts. Especially in the web-Hm. Maybe we will have two formats:
&gt;&gt; - internal, efficient representation: database tables
&gt;&gt; - external, human-readable, easy-to-parse, exportable and importable
&gt;&gt; representation: the current mail file format, XML or YAML.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; I like this idea. Still, a heap will be a documented format, one of
&gt; a set of possibilities: mailfiles, XML, YAML, SQL...
&gt;
&gt; A possible roadmap:
&gt; 1. Mailfile-based Hk with static HTML output (nearing completion, only lacking body parsing, as I see it)

</span></span>Nearing, especially if we decide to satisfy your needs that aren't
implemented yet within the web interface instead of the static web
interface.

<span class="quote"><span class="quote-1">&gt; 2. Mailfile-based Hk with Web interface
&gt; - at this point, we'll very probably need a single server (back to Shrek?)
&gt; - this will probably be the end of the distributed Git two-way
&gt; pulling storage mechanism (not necessarily, though, we could have a
&gt; discussion on this)

</span></span>I think we should discuss this in a separate thread (or even
thread-set), when we are ready. Do you think we are? Or should we
concentrate on the body parsing first?

<span class="quote"><span class="quote-1">&gt; 3. SQL-backed Hk with Web interface (with Mailfiles/XML/YAML
&gt; import/export capability)

</span></span><span class="quote"><span class="quote-2">&gt;&gt; For me "heap" is not a concrete format but rather an abstract one.
&gt;&gt; Like the expression "mailing list". The difference is that a heap has
&gt;&gt; posts instead of emails, and it has tags and meta text. (There may be
&gt;&gt; more differences, that's not the point.) The similarity is that both
&gt;&gt; have parent-children relationships, and threaded structure based on
&gt;&gt; these. Neither "heap" nor "mailing list" say how the posts/emails
&gt;&gt; shall be stored: they are just abstract concepts.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Thus, we have two things called 'heap':
&gt; - the idea of an editable mailing list and the associated terminology
&gt; - the syntax and semantics of header elements which I think will be
&gt; independent of the storage mechanism
&gt;
&gt; Should we distinguish these?

</span></span>They are distinguished, at least for me: I called the latter "mail
file". BTW, I want to propose renaming it, but I'll do that in a
separate mail.

<span class="quote"><span class="quote-2">&gt;&gt; - a library for editing of said list (called Heapmanipulator)
&gt;&gt; - a simple interactive interface for said library (called Heapia)
</span></span><span class="quote"><span class="quote-1">&gt;
</span></span><span class="quote"><span class="quote-2">&gt;&gt; I don't think of these as separate programs. Maybe when the web-Hm is
&gt;&gt; ready, we will have to think of them as separate entities. On the
&gt;&gt; other hand, we don't want to confuse users by telling them about a
&gt;&gt; bunch of different names when actually what now exists is just one
&gt;&gt; traditional software program and nothing else
</span></span><span class="quote"><span class="quote-1">&gt;
</span></span><span class="quote"><span class="quote-2">&gt;&gt; Similarly, we could say we have a program called Hm, which has a
&gt;&gt; console and a web interface, end of story.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; For that, the name 'Heapkeeper' (abbr. Hk) would be best.

</span></span>True. (At this point of the mail Hk has not been settled yet :) )

<span class="quote"><span class="quote-2">&gt;&gt; I think the users would be most happy with that solution.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; We are not yet at the point where we'd have 'ordinary' users
&gt; ignoring implementation details. Though, of course, it is our goal
&gt; to have them :)

</span></span>If we want to have developers, we will catch them only if they can
easily understand what we are doing. Understanding the program as a
user will help them to understand it as a developer.

<span class="quote"><span class="quote-2">&gt;&gt; Now the philosophy is that git is one program with many subcommands
&gt;&gt; (e.g. "git commit", "git checkout"), and invoking "git-commit" is
&gt;&gt; deprecated. The Unix philosophy with orthogonal tools is a good one,
&gt;&gt; but one should use it only when appropriate -- and in most cases it is
&gt;&gt; not. It is not appropriate in git's case and it is not appropriate in
&gt;&gt; our case.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Avoiding "bin pollution" via subcommands and Unixish tool
&gt; orthogonality are orthogonal.

</span></span>Almost. If git is a set of programs and you implement a few other
programs that operate on the same database, they could be seen as
being on the same level. On the other hand, if git is one tool with
subcommands and you create another program, everybody will think that
the comprehension between the git commands is far more than the
comprehension between a git command and yours. (Maybe there is a
better word instead of "comprehension"?)

E.g. if you write a program "cirmos" to be used in the unix shell, it
will be indistinguishable from "head" and "tail" in its use. That's
not true for git: "real" git commands run the "git" program, but your
commands won't.

So you are right in that using subcommands and Unixish orthogonality
are orthogonal things. On the other hand, they are not totally
independent: if you use subcommands, your _feeling_ of orthogonality
will be weaker.

<span class="quote"><span class="quote-1">&gt; You can (should) retain access to junction points in the plumbing
&gt; behind the uniform shining porcelain, like git has. Eg. you have
&gt; pull, but you still have fetch. (Is it a good example? You're much
&gt; better at Git than I am.)

</span></span>I don't think that's an example of orthogonality. That's an example of
git letting you work on different abstraction levels. Git doesn't do
that very often, but in this case it does. Another example for a
higher abstraction level is "git commit --amend".

Actually, I can't tell you any examples of orthogonality of the
subcommands. Maybe there is not any?

An example for another type of orthogonality is the parametrization.
You can specify a commit in many ways:
- SHA id
- HEAD
- &lt;commit&gt;^ (e.g. HEAD^^ is the commit before the commit before that head)
- &lt;commit&gt;~&lt;number&gt; (e.g. HEAD~2 is the same as HEAD^^)

The orthogonality is in the fact that you can use any format with any
git command.

<span class="quote"><span class="quote-2">&gt;&gt; So my proposal is having only these concepts that require a name:
&gt;&gt; - "heap": the abstract structure and the database that stores it
&gt;&gt; (regardless of the method of storage).
&gt;&gt; - "Heapkeeper": the name of the whole program, the name of the
&gt;&gt;  project, the name of the website, the name of the repository, the
&gt;&gt;  name of the mailing list -- sorry, the name of the heap :D
&gt;&gt; - "heapia" or "interactive console interface": the console interface
&gt;&gt;  of Heapkeeper. The user will think it is the "./heapia" shell script
&gt;&gt;  (or heapia.bat for windows users...), or it is at least started by
&gt;&gt;  that script.
&gt;&gt; - "heapweb" or "web interface": modules that allow using Heapkeeper
&gt;&gt;  via the web. Since we don't know how we will do this, we don't know
&gt;&gt;  if this will be one module like heapia, or many modules, or even
&gt;&gt;  some XML files, or something else.
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; OK.
&gt;
</span></span><span class="quote"><span class="quote-2">&gt;&gt; Shall we call our program Heapkeeper then? Of course it will be
&gt;&gt; abbreviated as Hk. (Which is better than Hm.)
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Hmm. This takes us back to the suit/non-suit problem above. What
&gt; binary(ies) or command(s) exactly do you propose to be called
&gt; Heapkeeper?

</span></span>Everything. We don't have any binaries, just a bunch of Python
modules; the set of Python modules that we create will be (is?)
Heapkeeper. heapia would be a part of Hk, so would be heapweb.

Did I answer your question?

<span class="quote"><span class="quote-2">&gt;&gt; If yes, then I will rename the github repository to "heapkeeper".
&gt;&gt; I'll create a heapkeeper.heap GMail account and a heapkeeper-heap
&gt;&gt; Google Group (although I think we won't use it until Hk supports
&gt;&gt; managing multiple heaps.)
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; The project name should be changed. What do you want to use these
&gt; new addresses for? Is this the new name for the place we want to
&gt; migrate the hh-part of the present-day Heap?

</span></span>Yes.
</pre></div>
</span><!-- postsummary -->

<div class="postbox"><!-- post hh/92 -->
<span class="postsummary" id="post_hh/92">
<span class="author">Csaba Hoch</span>
<span class="subject"><span class="star">&mdash;</span></span>
<span class="index"><a href="../hh/thread_67.html#post_hh/92">&lt;hh/92&gt;</a></span>
<span class="parent"><a href="../hh/thread_67.html#post_hh/88">&lt;&uarr;hh/88&gt;</a></span>
<span class="date">(2009-04-13)</span>
<div class="body">
<pre class="postbody"><span class="meta-text">[close]</span>

<span class="quote"><span class="quote-3">&gt;&gt;&gt; Shall we call our program Heapkeeper then? Of course it will be
&gt;&gt;&gt; abbreviated as Hk. (Which is better than Hm.)
</span></span><span class="quote"><span class="quote-2">&gt;&gt;
&gt;&gt; Hmm. This takes us back to the suit/non-suit problem above. What
&gt;&gt; binary(ies) or command(s) exactly do you propose to be called
&gt;&gt; Heapkeeper?
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Everything. We don't have any binaries, just a bunch of Python
&gt; modules; the set of Python modules that we create will be (is?)
&gt; Heapkeeper. heapia would be a part of Hk, so would be heapweb.
&gt;
&gt; Did I answer your question?
&gt;
</span></span><span class="quote"><span class="quote-3">&gt;&gt;&gt; If yes, then I will rename the github repository to "heapkeeper".
&gt;&gt;&gt; I'll create a heapkeeper.heap GMail account and a heapkeeper-heap
&gt;&gt;&gt; Google Group (although I think we won't use it until Hk supports
&gt;&gt;&gt; managing multiple heaps.)
</span></span><span class="quote"><span class="quote-2">&gt;&gt;
&gt;&gt; The project name should be changed. What do you want to use these
&gt;&gt; new addresses for? Is this the new name for the place we want to
&gt;&gt; migrate the hh-part of the present-day Heap?
</span></span><span class="quote"><span class="quote-1">&gt;
&gt; Yes.

</span></span>I renamed the repo to "heapkeeper". You should change "heap" to
"heapkeeper" in your .git/config.
</pre></div>
</span><!-- postsummary -->
</div><!-- postbox for post hh/92 -->
</div><!-- postbox for post hh/88 -->
</div><!-- postbox for post hh/84 -->
</div><!-- postbox for post hh/81 -->
</div><!-- postbox for post hh/71 -->
</div><!-- postbox for post hh/70 -->
</div><!-- postbox for post hh/69 -->
</div><!-- postbox for post hh/68 -->
</div><!-- postbox for post hh/67 -->

  </body>
</html>
